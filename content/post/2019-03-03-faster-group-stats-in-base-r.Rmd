---
title: Faster Group Stats in Base R
author: ~
date: '2019-03-03'
slug: faster-group-stats-in-base-r
categories: []
tags: []
image: /front-img/default.png
imagerect: ~
imagemrgvt: 0%
imagemrghz: 0%
draft: true
weight: 1
contenttype: article
description: Front page summary
---

```{r echo=FALSE}
options(digits=3)
knitr::opts_chunk$set(comment = "", fig.align='center', error=TRUE)
```

# blah blah

<!-- this needs to become a shortcode -->
<img
  id='front-img' src='/front-img/default.png'
  class='post-inset-image'
/>

# Baseline

```{r eval=FALSE}
RNGversion("3.5.2"); set.seed(42)
n     <- 1e7
n.grp <- 1e6
grp   <- sample(n.grp, n, replace=TRUE)
x     <- runif(n)
y     <- runif(n)

system.time(x.grp <- tapply(x, grp, sum))
```
```
   user  system elapsed
  8.539   0.321   9.030
```
```{r}
library(data.table)
DT <- data.table(grp, x)
setDTthreads(1)
system.time(DT[, sum(x), keyby=grp])
```
```
   user  system elapsed
  1.056   0.061   1.126
```

# Simple But Limited

Our first solution uses `base::rowsum`.  As the semantic capitalization and text
decoration conventions tell us, `base::rowsum` is completely different to
`base::rowSums`.  The singular lower case form indicates `base::rowsum`
collapses rows within groups, but preserves the columns.  Conversely, the plural
upper case form indicates that each row is collapsed into a single column, but
the row count is preserved.  The currently unimplemented `base::row.sum` and
`base::RowSums` will resolve world hunger and climate change respectively.
Other permutations of text decorations are reserved for future use.

As we've all read the "Semantics of Text Decoration in R Names" memo this is
obvious, but let's illustrate for completeness:

```{r}
mx <- matrix(1:8, 4, byrow=TRUE) * 10 ^ (0:3)
mx
```
```{r}
rowSums(mx)
```

`rowSums` turned Our 4 x 2 matrix into a 4 x 1 "column", or vector.

```{r}
rowsum(mx, group=rep(c('odd', 'even'), 2))
```

On the other hand `rowsum` preserved the two columns, collapsed the rows by the
`group` value.

You did get the memo, right?  Good.  I still shudder at the thought of the poor
sod that posted "gday" instead of "g.Day" in the _public_ R slack
channel[^love-r-but].




```{r eval=FALSE}
system.time(x.grp.2 <- rowsum(x, grp))
```
```
   user  system elapsed 
  2.505   0.096   2.626 
```
```{r eval=FALSE}
system.time({
  o <- order(grp)
  x.grp.2 <- rowsum(x[o], grp[o])
})
```
```
   user  system elapsed 
  1.408   0.113   1.556 
```
Slope:
```{r}
system.time({
o <- order(grp)
go <- grp[o]
xo <- x[o]
xs <- rowsum(xo, go)
xn <- rowsum(rep(1L, length(go)), go)
xi <- rep(seq_along(xs), xn)
xu <- (xs/xn)[xi]

yo <- y[o]
ys <- rowsum(yo, go)
yu <- (ys/xn)[xi]
x_ux <- xo - xu
y_uy <- yo - yu

rowsum(x_ux * y_uy, go) / rowsum(x_ux ^ 2, go)
})
```
```
   user  system elapsed 
  4.655   0.772   5.516 
```


```{r eval=FALSE}
# Note: adapted to handle na.rm as per winvector, don't necessarily
# handle corner cases correctly (0, 1 length vectors, others?)

# Note: this stuff is only fast because order(, method="radix") is fast

sum_g2 <- function(x, grp, na.rm=FALSE) {
  ord <- order(grp)
  grp.ord <- grp[ord]
  grp.rle <- rle(grp.ord)
  grp.rle.c <- cumsum(grp.rle[['lengths']])
  x.ord <- x[ord]
  has.na <- anyNA(x)

  if(has.na) {
    na.x <- is.na(x)
    x.ord[na.x] <- 0
  } else na.x <- logical()

  x.grp.c <- cumsum(x.ord)[grp.rle.c]
  x.grp.c[-1L] <- x.grp.c[-1L] - x.grp.c[-length(x.grp.c)]

  if(!na.rm && has.na)
    x.grp.c[match(grp.ord[na.x], grp.rle[['values']])] <- NA

  structure(x.grp.c, groups=grp.rle[['values']], n=grp.rle[['lengths']])
}
system.time(sum_g2(x, grp))
```
```
   user  system elapsed 
  1.186   0.374   1.634 
```
Try slope:
```{r eval=FALSE}

sum_grp_int <- function(x, last.in.group) {
  x.g <- cumsum(x)[last.in.group]
  x.g[-1L] <- x.g[-1L] - x.g[-length(x.g)]
  x.g
}
sum_grp <- function(x, last.in.group, precise=FALSE){
  x.grp <- sum_grp_int(x, last.in.group)
  if(precise) {
    x[last.in.group] <- x[last.in.group] - x.grp
    x.grp + sum_grp_int(x, last.in.group)
  } else x.grp
}
slope1 <- function(x, y, grp, precise=FALSE) {
  ord <- order(grp)
  grp.ord <- grp[ord]
  grp.rle <- rle(grp.ord)
  grp.rle.c <- cumsum(grp.rle[['lengths']])
  x.ord <- x[ord]
  y.ord <- y[ord]

  x.grp.c <- sum_grp(x.ord, grp.rle.c, precise=precise)
  y.grp.c <- sum_grp(y.ord, grp.rle.c, precise=precise)

  ux <- x.grp.c / grp.rle[['lengths']]
  uy <- y.grp.c / grp.rle[['lengths']]

  xi <- rep(seq_along(ux), grp.rle[['lengths']])
  x_ux <- x.ord - ux[xi]
  y_uy <- y.ord - uy[xi]

  x_ux.y_uy <- sum_grp(x_ux * y_uy, grp.rle.c, precise=precise)
  x_ux2 <- sum_grp(x_ux ^ 2, grp.rle.c, precise=precise)
  res4 <- x_ux.y_uy / x_ux2
}
system.time(slope1(x, y, grp, precise=FALSE))
```
```
   user  system elapsed 
  2.049   0.805   2.871 
```
Precision is garbage though:
```
> all.equal(res.slope.dt1[[2]], res4, tol=1e-2)
[1] TRUE
> all.equal(res.slope.dt1[[2]], res4, tol=1e-3)
[1] FALSE
```
But we can make it precise
```{r eval=FALSE}
system.time(slope1(x, y, grp, precise=TRUE))
```
```
   user  system elapsed 
  2.481   1.087   3.754 
```

```{r eval=FALSE}
sum_g3 <- function(x, grp, na.rm=TRUE) {
  ord <- order(grp)
  id.ord <- id[ord]
  grp.ord <- grp[ord]
  grp.rle <- rle(grp.ord)
  max.grp <- max(grp.rle[['lengths']])

  res <- matrix(NA_real_, ncol=length(grp.rle[['lengths']]), nrow=max.grp)

  # each group that isn't as long as the longest group needs padding

  rle.len <- grp.rle[['lengths']]
  grp.pad <- max.grp - rle.len
  id.raw <- rep(1L, length(x))
  id.raw[(cumsum(rle.len) + 1L)[-length(rle.len)]] <-
    grp.pad[-length(rle.len)] + 1L
  id <- cumsum(id.raw)

  res[id] <- x[ord]
  structure(colSums(res, na.rm=na.rm), groups=grp.rle[['values']])
}
system.time(sum_g3(x, grp))
```
```
   user  system elapsed 
  1.186   0.374   1.634 
```
```{r eval=FALSE}

DT <- copy(DT.raw)
system.time(res.ref <- DT[, sum(x), keyby=grp][['V1']])
#   user  system elapsed
#  1.071   0.134   1.216
system.time(res <- sum_g2(x, grp))
#   user  system elapsed
#  1.286   0.309   1.692
all.equal(res, res.ref, check.attributes=FALSE) # TRUE

system.time(res2 <- sum_g2(x, grp))
system.time(res3 <- sum_g3(x, grp))
system.time(res4 <- rowsum(x, grp))

sum_winvector <- function(DF) {
  odata <- DF[order(DF$grp),,drop=FALSE]
  first_indices <- mark_first_in_each_group(odata, "grp")
  sum_g(odata[['x']], first_indices)
}
```
```
  user  system elapsed
 1.810   0.740   2.651
```
Note on vector size[^vec-size].


# Conclusions

<!-- this needs to become a shortcode -->
<!-- this is populated by JS in feedback.html partial -->
<div id='feedback-cont'></div>

# Appendix

[^vec-size]: Numeric vectors require 8 bytes per element plus some overhead for
the object meta data.
[^love-r-but]: I love R, but the maddness around [text decoration
conventions][1] is something that I could do without.  Sorry for the rant, but I
was particularly triggered by this example.

[1]: https://twitter.com/BrodieGaslam/status/976616435836510210
