---
title: Mesh Reduction 1
author: ~
date: '2019-08-23'
slug: mesh-reduction-1
categories: []
tags: []
image:
  /post/2019-08-23-mesh-reduction-1_files/images/batch-2.png
imagerect: ~
imagemrgvt: 0%
imagemrghz: 0%
weight: 1
contenttype: article
description: Front page summary
---

```{r echo=FALSE}
options(digits=3)
knitr::opts_chunk$set(comment = "", fig.align='center', error=TRUE)
```

# Header 1

<!-- this needs to become a shortcode -->
<img
  id='front-img'
  src='/post/2019-08-23-mesh-reduction-1_files/images/batch-2.png'
  class='post-inset-image'
/>

A few months ago a stumbled on Vladimir Agafonkin's fantastic observable
notebook on the [adaptation of the Right-Triangulated Irregular Networks (RTIN)
algorithm][6].  The subject matter is interesting and the exposition superb.
I'll admit I envy the elegance of natively interactive notebooks.

I almost left it at that, but then the irrepressible "but can we do that in R"
bug in whispered into my ear, once again setting me hopelessly
off-course[^off-course].  Obviously we can do it by porting the code directly,
but the loop heavy nature of it would doom it.  We could also trivially port it
to C and interface that into R, but where's the fun in that?

# The Algorithm

You should look at [Agafonkin's notebook][6] or the original [Will Evans et al.
1997 paper][8] for in-depth details as the point of this post is the translation
to an R idiomatic implementation.  Notwithstanding I can't resist indulging in
some of my newly acquired `rayrender`ing powers for some illustrations.

The basic idea is to approximate a triangle mesh with fewer triangles while
keeping the approximation error within certain tolerances.  For example here we
approximate the beloved `volcano` mesh (glass) at three increasingly relaxed
tolerance levels (gold, silver, and copper meshes):

<!--
Maybe better here would be to have a full resolution version of first level of
approx on volcano, with glass, and then show the increasing levels with the
original glass?  Should we use the full mesh of volcano, or the already
partially reduced one?
-->

<img class='aligncenter'
  src='/post/2019-08-23-mesh-reduction-1_files/images/glass-and-mesh-3-f-merge.png'
/>

If you look closely you'll see that even in the higher fidelity approximation
the wire mesh ends up above or below the glass surface, although on the whole
the approximation is good.

If we flatten the elevation component of the meshes and change our viewpoint it
becomes apparent that all the triangles in the approximation are right angled
isoceles triangles.  This is where the "Right-Triangulated" part of the
algorithm name comes from.

<img class='aligncenter'
  src='/post/2019-08-23-mesh-reduction-1_files/images/batch-4.png'
/>

Another important feature of this mesh approximation is that it is hierarchical.
When we stack the three meshes we can see that each low resolution triangle is
exactly replaced by higher resolution ones when it does not meet the error
tolerance:

<img class='aligncenter'
  src='/post/2019-08-23-mesh-reduction-1_files/images/batch-1.png'
/>

If a triangle too coarse for the desired level of fidelity, it is broken up into
two smaller triangles.  If those triangles are still too coarse, they too are
broken up.

In order to decide whether an approximate is faithful enough we measure the
error between each level of mesh approximation at the middle of
the hypotenuse of each triangle.  For the sake of exposition we will temporarily
abandon volcano and switch to a simple 3x3 elevation surface, and we will show
approximations where at each level every triangle is the same size.

<img class='aligncenter'
  src='/post/2019-08-23-mesh-reduction-1_files/images/simple-mesh-s-merge.png'
/>

At the most granular level (gold) there is no error as the mesh corresponds
exactly to the elevation surface.  At the first level of approximation (silver)
error appears around the periphery of the surface as that is where the triangle
edges skip over surface vertices.  We show these errors as a checkered cylinder.
At the coarsest level of approximation (copper) we generate additional error on
the center of the surface and show that too as a checkered cylinder.

Errors are measured at the middle of the hypotenuse of the triangles.  This is
not arbitrary: as we merge triangles together to increase coarseness, the
vertices that are lost correspond to that point of the parent triangle.  An
implication is that we never measure errors from different levels of
approximation at overlapping locations, so we can store the errors in a single
matrix:

<!--
Error matrix, just the cylinders
-->

For clarity the surface was constructed so that all the errors are in the same
direction and directly visible from our observation point.  In practice the
errors can occur on either side of the surface, and we would record their
absolute values.  The corners of the matrix will never have any error as even the coarsest level
of approximation will have vertices at those locations.

We can now compare our recorded errors to different tolerance levels, and use
that to decide what triangles to draw.  A possible algorithm is to draw the
child triangles of any triangle for which its error or the error of any of its
descendants exceeds the threshold.  Here we represent a possible threshold as
the "water" level; errors poking above it must be addressed:

<!--
Error threshold such that worst error in middle and center error trigger.

Image is side by side (left/right):

* Left: error matrix, water level added
* Right: mesh approximation, gold/silver, gold drawn last
-->

Looks great.  Unlike with our original `volcano` meshes we are treating the mesh
color to correspond to a specific level of approximation.  But notice what
happens if we increase the tolerance level:

<!--
Error threshold such that only the worst error triggers

Image is side by side (left/right):

* Left: error matrix, water level added
* Right: mesh approximation, complete mess
-->

Gah, there are gaps!  This is particularly apparent if we try to draw the
approximated surface, rotated here so we can see the gap:

<!--
Glass surface approximated and rotated showing gap
-->

To resolve this we carry over errors from children triangles to their parents
and override use the largest of the child errors and the parent error as the
parent error:

<!--
Two error matrices:

* Left: original, but with arrows showing errors converging onto parent
* Right: original, but with parent error adding child error stacked on top of it
-->

the error is shown as checkered cylinders.  Because child triangles are formed
from parent ones by splitting the parent at the middle of the hypotenuse, and
errors are measured at this point, errors from different levels of approximation
will never overlap.  This allows us to store all the errors in a single matrix.
We can then compare this error matrix

<!--
Show the matrix with the errors?  Also show two more with different water
levels.
-->

Suppose we tolerate errors that are below different "water-levels".  In the
middle case every approximation exceeds the desired threshold so the
approximated surface will look the same as the original.  In the last case
though only one approximation is inadequate.  One possible way to interpret this
data to produce our approximate mesh is to draw the lowest detail triangles 


can be broken up 
replaced
with the smaller triangles it comprises.  One restriction brought about by this
hierarchy is that the mesh must be square and `$2^k + 1$` to the side (not
strictly true).

The first step of the algorithm is to compute the error caused by each level of
approximation.  Subsequently that error can be compared against a tolerance and
the mesh can be drawn from the triangles that meet it.  In this post we will
focus on the error computation part.

Error is computed at the middle of the hypotenuse of each triangle:

```{r error-ex}
## Simplest example of error, 3x3 grid.  Actually, might need a 5x5 grid to show
## the complexity of the child errors?
```

There is a complication though.  We can't just break up triangles into smaller
pieces willy nilly as otherwise we end up with problems.  This is resolved by
carrying over the error in any given triangle to it's parent triangle to ensure
that triangles are broken up in a self-consistent way.  I.e., if a triangle is
broken up, then all it's siblings must be drawn (or something like that anyway)..

```{r child-ex}
## Example of what happens if we don't spread the error to parents
```

We can see the algorithm in action:

<!-- Animation here -->


# Vectorize The Shit Absolute Shit Out Of This


```{r test-plot}
plot(1:10, 1:10)
```

# Conclusions

<!-- this needs to become a shortcode -->
<!-- this is populated by JS in feedback.html partial -->
<div id='feedback-cont'></div>

# Appendix

## Acknowledgments

* rgl
* rayrender
* Agafonkin
* reshape2
* ggplot2


## System Info

[^off-course]: The beauty is I wasn't going anywhere in particular anyway, so
  why not do this.

[6]: https://observablehq.com/@mourner/martin-real-time-rtin-terrain-mesh
[7]: https://twitter.com/mdsumner/status/1161994475184373761?s=20
[8]: https://www.cs.ubc.ca/~will/papers/rtin.pdf
