---
title: Mesh Reduction 1
author: ~
date: '2019-08-23'
slug: mesh-reduction-1
categories: []
tags: []
image:
  /post/2019-08-23-mesh-reduction-1_files/images/batch-2.png
imagerect: ~
imagemrgvt: 0%
imagemrghz: 0%
weight: 1
contenttype: article
description: Front page summary
---

```{r echo=FALSE}
options(digits=3)
knitr::opts_chunk$set(comment = "", fig.align='center', error=TRUE)
```

# Header 1

<!-- this needs to become a shortcode -->
<img
  id='front-img'
  src='/post/2019-08-23-mesh-reduction-1_files/images/batch-2.png'
  class='post-inset-image'
/>

A few months ago a stumbled on Vladimir Agafonkin's fantastic observable
notebook on the [adaptation of the Right-Triangulated Irregular Networks (RTIN)
algorithm][6].  The subject matter is interesting and the exposition superb.
I'll admit I envy the elegance of natively interactive notebooks.

I almost left it at that, but then the irrepressible "but can we do that in R"
bug in whispered into my ear, once again setting me hopelessly
off-course[^off-course].  Obviously we can do it by porting the code directly,
but the loop heavy nature of it would doom it.  We could also trivially port it
to C and interface that into R, but where's the fun in that?

# The Algorithm

You should look at [Agafonkin's notebook][6] or the original [Will Evans et al.
1997 paper][8] for in-depth details as the point of this post is the translation
to an R idiomatic implementation.  Notwithstanding I can't resist indulging in
some of my newly acquired `rayrender`ing powers for some illustrations.

The basic idea is to approximate a triangle mesh with fewer triangles while
keeping the approximation error within certain tolerances.  For example here we
approximate the beloved `volcano` mesh at three increasingly relaxed tolerance
levels:

<img class='aligncenter'
  src='/post/2019-08-23-mesh-reduction-1_files/images/batch-5.png'
/>

If we flatten the elevation component of the meshes and change our viewpoint it
becomes apparent that all the triangles in the approximation are right angled
isoceles triangles.  This is where the "Right-Triangulated" part of the
algorithm name comes from.

<img class='aligncenter'
  src='/post/2019-08-23-mesh-reduction-1_files/images/batch-4.png'
/>

Another important feature of this mesh approximation is that it is hierarchical.
When we stack the three meshes we can see that each low resolution triangle is
exactly replaced by higher resolution ones when it does not meet the error
tolerance:

<img class='aligncenter'
  src='/post/2019-08-23-mesh-reduction-1_files/images/batch-1.png'
/>

If a triangle too coarse for the desired level of fidelity, it is broken up into
two smaller triangles.  If those triangles are still too coarse, they too are
broken up.  The approximation error is measured at the middle of the hypotenuse
of each triangle:

<!--
Show 
-->

can be broken up 
replaced
with the smaller triangles it comprises.  One restriction brought about by this
hierarchy is that the mesh must be square and `$2^k + 1$` to the side (not
strictly true).

The first step of the algorithm is to compute the error caused by each level of
approximation.  Subsequently that error can be compared against a tolerance and
the mesh can be drawn from the triangles that meet it.  In this post we will
focus on the error computation part.

Error is computed at the middle of the hypotenuse of each triangle:

```{r error-ex}
## Simplest example of error, 3x3 grid.  Actually, might need a 5x5 grid to show
## the complexity of the child errors?
```

There is a complication though.  We can't just break up triangles into smaller
pieces willy nilly as otherwise we end up with problems.  This is resolved by
carrying over the error in any given triangle to it's parent triangle to ensure
that triangles are broken up in a self-consistent way.  I.e., if a triangle is
broken up, then all it's siblings must be drawn (or something like that anyway)..

```{r child-ex}
## Example of what happens if we don't spread the error to parents
```

We can see the algorithm in action:

<!-- Animation here -->


# Vectorize The Shit Absolute Shit Out Of This


```{r test-plot}
plot(1:10, 1:10)
```

# Conclusions

<!-- this needs to become a shortcode -->
<!-- this is populated by JS in feedback.html partial -->
<div id='feedback-cont'></div>

# Appendix

## Acknowledgments

## System Info

[^off-course]: The beauty is I wasn't going anywhere in particular anyway, so
  why not do this.

[6]: https://observablehq.com/@mourner/martin-real-time-rtin-terrain-mesh
[7]: https://twitter.com/mdsumner/status/1161994475184373761?s=20
[8]: https://www.cs.ubc.ca/~will/papers/rtin.pdf
