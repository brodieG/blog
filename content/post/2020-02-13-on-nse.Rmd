---
title: On NSE
author: ~
date: '2020-02-13'
slug: on-nse
categories: []
tags: []
image: /front-img/default.png
imagerect: ~
imagemrgvt: 0%
imagemrghz: 0%
weight: 1
contenttype: article
description: Front page summary
output:
  blogdown::html_page:
    keep_md: yes
    md_extensions: +raw_attribute
---
```{r echo=FALSE, child='../../static/chunks/init.Rmd'}
```
# With Great Freedom...

<img
  id='front-img' src='/front-img/default.png'
  class='post-inset-image'
/>

Non-Standard Evaluation is a pretty controversial topic in R circles, and even
in the R documentation.  Whether you like it never, sometimes, or always, is
neither here nor there.  What matters is that R allows it.  Not many languages
give the programmer the power to implement, use, and abuse Non-Standard
Evaluation ("NSE"), or anything like it.

So what is NSE?  Very roughly, it is to programmatically modify a command or its
meaning after it is issued but before it is executed.  For example in:

```{r}
subset(mtcars, hp > 250)
```

The command `hp > 250` is intercepted before it is run, and its meaning is
changed by allowing `hp` to resolve against columns from `mtcars` instead of
against objects in the workspace.  Compare what happens with a command that is
evaluated in the standard way:

```{r}
mtcars[hp > 250,]
```

We get an error because `hp` does  not exist in my workspace.

# Standard Evaluation

When we type a simple command at the R prompt and hit ENTER, R computes its
value (a.k.a. evaluates it):

```{r echo=FALSE}
y <- c("am", "I", "why")
z <- c(1, 5, 9, 8)
```
```{r}
w <- c("am", "I", "global")
rev(w)           # reverse the order of vector `x`
```

Ironically the process of evaluation in R is mostly about looking things up
rather than computing them.  In our example, when we hit ENTER R first looks for
the named objects in our command: `rev`, and `w`[^parens].  Lookups are done
through data structures called environments, represented in blue in this
flipbook:

```{r eval=FALSE, echo=FALSE}
# code to generate flipbook images
source('static/script/mesh-viz/viz-lib.R')
png.in <- list.files(
  'static/post/2020-02-13-on-nse_files/templates/anim4',
  full.names=TRUE
)
png.dat <- lapply(png.in, png::readPNG)
png.a <- trim_png(png.dat[1:6], pad=c(10,10))
fname <- 'static/post/2020-02-13-on-nse_files/images/flip-1/img-%03d.png'
lapply(
  seq_along(png.a), function(x) png::writePNG(png.a[[x]], sprintf(fname, x))
)

ids <- 7:13
png.a <- trim_png(png.dat[ids], pad=c(10,10))
lapply(
  seq_along(ids), function(x) png::writePNG(png.a[[x]], sprintf(fname, ids[[x]]))
)

ids <- 14:15
png.a <- unlist(lapply(
  png.dat[ids], function(x, pad) trim_png(list(x), pad=pad), pad=c(10,10)
), recursive=FALSE)
lapply(
  seq_along(ids), function(x) png::writePNG(png.a[[x]], sprintf(fname, ids[[x]]))
)
```

<div id='flipbook1'></div>

After the lookup `rev(w)` becomes:

```
(function(x) UseMethod("rev"))(c("am", "I", "global"))
```

`rev` is replaced by the definition of the function from the base environment,
and `w` by the character vector from the workspace.  The workspace, also known
as the global environment, is where name -%gt; value mappings created at the
R prompt are kept (e.g. `w <- c("am", "I", "global")`).

Our substituted command is a bit weird in appearance, but more useful to R as
the names `rev` and `w` have no inherent meaning.  There is _a fair bit_ of hand
waving here[^simple-model], but for the most part the lookup-and-substitute
model reflects observed R behavior.  

R is not yet done with our command.  More on this shortly, but first lets talk
about environments.

# Environments

<span id='env-desc'>Environments are akin to named lists with a few additional
features.  All elements are uniquely named, and the names can be [hashed][25]
for fast lookups.  This name -&gt; object mapping is known as the "Frame" of
the environment.  <span id='enclos'>Environments also carry a link to an
"Enclosing Environment" a.k.a. "Enclosure" (black arrows in the flipbook,
pointing to the Enclosure).  The Frame and the link to the Enclosure together
make up the environment.</span></span>

> **WARNING**: Environments have reference semantics.  Be sure you
> understand the [documentation][24] before you attempt to directly modify
> elements in environments, e.g. as in `env$name[3] <- 42`.  We do not write to
> environments here so this isn't important for our discussion, but be wary
> when interacting with them directly.

R searches for a name in an environment's Frame, and if it doesn't find it moves
on to its Enclosure, and repeats the process until the name is found or it runs
out of Enclosures.

When searching for `rev`, R will work through the entire environment chain down
to the base package to retrieve the `base::rev` function[^pathological-pkg].
For commands typed at the prompt the environment chain usually starts at the
global environment and links the environments of all the attached
packages[^attached] (represented with the `...` below) through to the base package.

<img
  src='/post/2020-02-13-on-nse_files/images/flip-1/img-002.png'
  alt='Retrieving `rev` from the base environment'
/>

When searching for `w` R will find it immediately in the global environment and
stop the search:

<img
  src='/post/2020-02-13-on-nse_files/images/flip-1/img-004.png'
  alt='Retrieving an object from the global environment'
/>

<span id=eval-env>The first environment in the environment chain is called the
"Evaluation Environment"[^env-vs-chain].  We'll say that commands are
"evaluated in" the Evaluation Environment, even though what we really mean is
that they are evaluated according to the environment chain that starts with that
Evaluation Environment.</span>

When evaluating commands at the R prompt, the Evaluation Environment is usually
the global environment, so this may all seem moot.  However, commands can be
issued in different Evaluation Environments, as is the case when they are
part of the body of a function.

# In Functions

After the initial substitution of `rev` and `w` for the function and its
argument, R will "run" the function, which means recursively repeating the
lookup-and-substitute process on the body of the function.  This continues until
we hit the special `.Primitive`, `.Internal`, `.Call`, and
similar[^static-compile-funs] entry points to statically compiled machine
code[^use-method].

Normal R Functions  add some wrinkles to the lookup-and-substitute step of
evaluation.  These functions are known as closures[^closures] because they carry
a reference to an environment to use as an [Enclosure](#enclos) when they are
evaluated.  We'll call this environment the Function Enclosure.

<span id=fun-eval-env>When such a function is invoked, it creates a new
environment with the aforementioned [Enclosure](#enclos), and populates it with
its parameters mapped to the values supplied for its
arguments[^promises-actually].  This new environment is the function's
Evaluation Environment in which the commands from the function body will be
evaluated[^fun-body].</span>

`rev` happens to just have one command in its body:

Typically the [Enclosure](#enclos) is the package namespace the
functions belong to, or the [Evaluation Environment](#eval-env) the functions
were defined in[^fun-create].


```{r}
body(rev)
```

And a flipbook of this process:

<div id='flipbook2'></div>

In `<rev>` we have the name `x` corresponding to its one argument.  It is
associated to the same value[^value-copy] as `w` from the global environment
because the original call `rev(w)` was evaluated in the global environment.  The
previous environment chain shown in the background still exists but it's
inactive at the moment.

Now that the new evaluation environment is set we proceed with the same name
substitution [observed previously](#flipbook1).  `UseMethod` will be retrieved
from the base environment (not shown, but it's there I promise), and it will be
"run" just as `rev` was.  

Important take-aways from this section:

1. Commands acquire their meaning when the names therein are substituted with
   objects they reference.
2. Names are resolved to objects by looking them up through environment chains.
3. The environment chain, and hence the meaning of commands, is set by the
   environment that is designated as the Evaluation Environment.

> For a more complete treatment of environments and how they are used by R do
> read Saruj Gupta's ["How R Searches and Finds Stuff"][29].

# Masking

It is possible for different environments to contain the same name.  When this
happens the object returned is the one from the first environment along the
chain that contains that name.  Consider what happens if we nest our simple
`rev(x)` command in a trivial function:

<span id='fun'>
```{r}
fun <- function() {
  w <- c("am", "I", "fun")
  rev(w)
}
fun()
```
</span>

As we saw [earlier](#fun-eval-env), R will create an evaluation environment to
evaluate the body of `fun`.  Since `fun` was created in the global environment,
that will be the enclosure for the function evaluation environment.  As a
result, by running `rev(w)` inside of `fun` instead of directly at the prompt we
changed the evaluation environment for the command.  This is what the
environment chain looks like now:

<img
  src='/post/2020-02-13-on-nse_files/images/flip-1/img-014.png'
  alt='How a function environment modifies the environment chain.'
/>

The evaluator finds `w` in the function's evaluation environment instead of the
now-masked `w` in the global environment and so substitutes a different value
for it.

# Non-Standard Evaluation

Before we go on, a quick flash-back to standard evaluation:

```{r}
rev(w)
```

Consider instead:

```{r}
L <- list(w=c("am", "I", "list"))
with(
  L,
  rev(w)     # same commmand
)
```

What happened?  The names in `rev(w)` were matched against the list `L`.  In
other words, `L` masked the name search as [`fun`'s evaluation environment
did](#fun), except we didn't need to define a function.

While the concept is straightforward the execution is more complicated.
`with` needs mechanisms for interrupting the evaluation, masking the
active environment chain in some way with `L`, and resuming evaluation.  R,
being the strange language that it is, provides tools to do all this.

Let's implement a version of `with` at the prompt to see how this might be
done:

```{r}
cmd  <- quote(rev(w))       # capture command
Lenv <- list2env(L)         # convert list to env
eval(cmd, envir=Lenv)       # invoke the evaluator
```

`quote` captures a parsed R command before the evaluator gets to it.  Once
captured the command no longer self-evaluates at the prompt, that is if you type
it at the prompt you get the unsubstituted, un-run command back:

```{r}
cmd    # we get command back, not result of evaluating it
```

It may not seem like much, but it's a big deal R allows this: unevaluated R
commands can be directly manipulated by R itself.  We won't use that capability
here as all we care about at the moment is that the evaluation is on hold.  For
an example of what you can do with quoted commands see the [RPN in R post][28].

`list2env` creates a new environment which has for enclosure the global
environment as that is where we called it from.  This is possible because
environments are [akin to named lists](#env-desc).

```{r}
Lenv
ls.str(Lenv)
```
```{r}
parent.env(Lenv)   # parent.env == enclosure
```

`eval` provides a mechanism to resume evaluation with a different environment
chain for name lookups:

```{r}
eval(cmd, envir=Lenv)
```

This is what the environment chain looks like now right before substituting the
`w` name[^no-fun]:

<img
  src='/post/2020-02-13-on-nse_files/images/flip-1/img-015.png'
  alt='Adding an environment to the environment chain with eval.'
/>

By changing the environment chain we made the evaluation "Non-Standard".


Running `eval` without changing the starting environment produces the same
result as if we had typed the command at the prompt:

```{r}
eval(cmd) # envir defaults to parent.frame (global here)
```

Now look at what happens if we make a new mask that contains a `rev` symbol as
well:

```{r}
L2 <- list(rev=toupper)
L2env <- list2env(L2, parent=Lenv)
eval(cmd, envir=L2env)
```

We can change the meaning of both functions and values by modifying the
environment chain.  Notice how we set the enclosure to `L2env` to be `Lenv` with
the `parent` parameter to `list2env`[^par-vs-enc].  We could also have directly
added a `rev` mapping to `Lenv`.

Manipulating the environment chain is not the only way to perform NSE.  Anything
that changes the meaning of a command after it is issued relative to what would
have happened in standard evaluation is NSE.

# In Functions

Compare:

```{r}
with(L, rev(w))
```

To our hack-at-the-prompt version:

```{r}
cmd  <- quote(rev(w))
Lenv <- list2env(L)
eval(cmd, envir=Lenv)
```

It would be nice to implement `with` ourselves, if we try to use `quote` inside
a function to get what someone types in as the argument to that function we are
disappointed:

```{r}
with2 <- function(dat, cmd) {
  quote(cmd)                 # capture command
  # rest of function will go here later
}
with2(L, rev(w))
```

What we want to quote is the command supplied argument `cmd`, not the name
`cmd`.  Thankfully R in its infinite flexibility provides a mechanism for doing
this with `substitute`:

```{r}
with2 <- function(dat, cmd) {
  substitute(cmd)
  # rest of function will go here later
}
with2(L, rev(w))
```

When called within a function on a function parameter, `substitute` acts like
`quote` except it substitutes the unevaluated command passed as the actual
parameter.  This allows us to implement `with`:

```{r}
with2 <- function(dat, cmd) {
  cmd2 <- substitute(cmd)
  denv <- list2env(dat, parent=parent.frame())
  eval(cmd2, envir=denv)
}
with2(L, rev(w))
```

We can do a bit better because `eval` supports adding a list-like element to the
environment chain out of the box:

```{r}
with2 <- function(L, cmd) {
  cmd2 <- substitute(cmd)
  eval(cmd2, L, enclos=parent.frame())
}
with2(L, rev(w))
```

What's the `parent.frame()` business?  And why do we pass it as the `enclos`
argument for `eval`, but as the argument `parent` for `list2env`?

# Environmental Dichotomy

`substitute` allows us to implement functions that perform NSE on their
arguments.  This is a powerful feature, but with it comes a new class of
potential errors.  Notice in our `with2` implementation how we call `eval`:

```{r eval=FALSE}
eval(cmd2, L, enclos=parent.frame())
```

The key part is that we explicitly specify the enclosure to be `parent.frame()`.
We must do this to ensure the correct environment chain is used to resolve the
names in `cmd2`, i.e. `rev(w)`.  What is `parent.frame()`?  It is the
environment that the function currently under evaluation (`with2` here) was
invoked from.  We will call this environment the **calling** environment.

To understand why we must call `eval` with the enclosure set to the **calling**
environment, consider what happens when we don't do it:

```{r}
with2_bad <- function(L, cmd) {
  cmd2 <- substitute(cmd)
  eval(cmd2, L)
}
with2_bad(L, rev(w))
```

No problem right?  Except look at what happens with a pathological input:

```{r}
cmd2 <- c("pathological", "I", "am")
with2_bad(L, rev(cmd2))
```

Wow, what the heck is that?  It is the result of:

```{r}
rev(quote(rev(cmd2)))
```

The key thing to realize is that we had a name clash.  The `cmd2` symbol
associated in `with2_bad`'s **evaluation** environment masks the `cmd2` in the
**calling** environment.  We can avoid the clash by ensuring the current
**evaluation** environment is not involved in the call to `eval`.  `with2` does
this by setting the `enclosure` for `eval` to the **calling** environment so it
works as expected:


```{r}
cmd2 <- c("pathological", "I", "am")
with2(L, rev(cmd2))
```

No, you're not pathological, not anymore.

This is a contrived example as it requires the function doing NSE to have names
that mask those used in the captured call, but there are other ways things go
wrong.  If our function were called from within another function, then the names


```{r}
friendly_fun <- function(L) {
  z <- c('hello', 'friend', '!')
  with2_bad(L, paste(c(z, w), collapse=' '))
}
friendly_fun(L)
```

What happened?  Instead of using the `z` in `fun2`'s evaluation environment,
which in this case is `with2_bad`'s **calling** environment, we used the `z` in
the global environment.  Why?  Because the `with2_bad`'s **function**
environment, and hence the enclosure of it's **evaluation** environments, is the
global environment.  Again, this is resolved by explicitly setting the
evaluation enclosure to the **calling** frame with `parent.frame` as `with2`
does:

```{r}
friendly_fun <- function(L) {
  z <- c('hello', 'friend', '!')
  with2(L, paste(c(z, w), collapse=' '))
}
friendly_fun(L)
```



# Conclusions

<!-- this needs to become a shortcode -->
<!-- this is populated by JS in feedback.html partial -->
<p id='feedback-cont'></p>

# Appendix

## References

* [Survey of Macros in R][22]
* [R NSE Reference][27]
* [Tips on NSE in R][29] by Kun Ren
* [Original R Paper][30]


## Acknowledgments

Sumner.

* png

## Session Info

<!--
```{r child='../../static/script/_lib/zoom-img/zoom-img.Rmd', results='asis', cache=FALSE}
```
-->
```{r child='../../static/script/_lib/flipbook/flipbook.Rmd', results='asis', cache=FALSE}
```
<script type='text/javascript'>
const imgDir = '/post/2020-02-13-on-nse_files/images/flip-1/';
const fps = 1;
new BgFlipBook({
  targetId: 'flipbook1', imgDir: imgDir, imgStart: 1, imgEnd: 6,
  imgPad: "000", fps: fps, loop: true
})
new BgFlipBook({
  targetId: 'flipbook2', imgDir: imgDir, imgStart: 7, imgEnd: 13,
  imgPad: "000", fps: .3, loop: true, loopDelay: 3000
})
</script>

[20]: https://cran.r-project.org/doc/manuals/R-lang.html#Argument-evaluation
[21]: https://stat.ethz.ch/R-manual/R-devel/library/compiler/html/compile.html
[23]: https://github.com/WinVector/wrapr/blob/master/extras/MacrosInR.md
[24]: https://cran.r-project.org/doc/manuals/R-lang.html#Environment-objects
[25]: https://en.wikipedia.org/wiki/Hash_table
[26]: http://blog.obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/
[27]: http://developer.r-project.org/nonstandard-eval.pdf
[28]: /2019/01/11/reverse-polish-notation-parsing-in-r/
[29]: https://renkun.me/2014/12/03/tips-on-non-standard-evaluation-in-r/
[30]: https://www.stat.auckland.ac.nz/~ihaka/downloads/R-paper.pdf
[82]: /2019/02/18/an-unofficial-reference-for-internal-inspect/

[^earth-shattering]: Under no circumstances
[^more-complicated]: The actual meaning changes is more complicated, but we'll
  discuss that in the body of this post.
[^simple-model]: <span id='simple-model'>Items we gloss over include but are not
  limited to:<ul>
  <li>Function parameters are [evaluated lazily][20] so they are only fetched
  when they are referenced within a function body as something other than an
  argument to a closure (e.g. as an argument to a primitive or other entry
  points into statically compiled machine code, or simply as a stand-alone
  reference to the name as in `force`).
  <li>What is fetched is a pointer to the location in memory the R objects are
  stored in, not the objects proper.  Since in R memory addresses are not
  directly visible, we'll treat the pointers as if they are the actual R
  objects they reference.
  <li>The [byte-compiler][21] affects the nature of non-evaluated code
  prefetching the objects names point to and performing other optimizations, and
  generally bypassing many aspects of the "normal" evaluation process.
  <li>Names representing called functions are only resolved against names that
  are associated with functions.
  <li>Lookups from the global environment down are usually done against a
  "global" hash table that replicates the semantics of the environment chain,
  but isn't actually a chain.
  <li>The base environment has an enclosure, although it is the empty
  environment which itself does not have an enclosure.
  <li>And more.</ul></span>
[^mostly-names]: In R "names" are not restricted to words in the typical sense.
  Symbols like `*`, `+`, and even `(` in some circumstances are also called
  "names".  "names" are also called "symbols" and the terms are often used
  interchangeably in the documentation.
[^parens]: The parentheses in `rev(x)` are not considered "names".  They are
  syntax tokens that are used to parse the command.  Opening parentheses that
  are not part of the syntax of a function call are names, as in `(1 + 2) * 3`.
[^run-recursive]: Where by "run the function" means retrieving the body of the
  function, and repeating the fetching we just went through, until eventually we
  start hitting statically compiled functions invoked via `.Primitive`,
  `.Internal`, and similar, when the actual computation occurs.  All the
  [aforementioned caveats](#simple-model) still apply, in particular that names
  are not actually substituted until they are used in a function body.
[^weapons-grade]: In reality the names are not substituted in place as we show
  here.  R will hold the function and a list of the arguments encapsulated as
  [promises](#promises-actually) which it can then use to evaluate the body of
  the function.  Because the arguments are kept as promises they are not
  actually substituted until they are used in the body of the function, or in
  those of subsequent functions that they are forward to, or not all if they are
  not used.  However, in most cases were the argument is used and evaluating it
  does not use side-effects, the observed behavior is as if the names had been
  substituted in place, or at least in place in a copy of the list.
[^promises-actually]: <span id=promises-actually>In reality instead of the
  values of the arguments, R stores the command passed as the argument along
  with the environment to evaluate it in.  If the argument is used by the
  function then the command is evaluated in its environment to produce the
  value.  This is typically the same as if R had used the values directly, but
  there are some circumstances where behavior is changed due to this feature.
  Values that are stored as the command used to generate them along with the
  environment to evaluate that command are known as promises</span>
[^pathological-pkg]: Well, it will unless you have loaded a pathological package
  that also defines a `rev` function, or if you yourself define a `rev` function
  in the global environment.
[^fun-env-term]: <span id=fun-env-term>The correct term for what we call the
  "function enclosure" is "environment to use as the enclosure for the function
  evaluation environments".  So "function enclosure" is not strictly correct,
  but neither is "function environment", and "function enclosure" is much closer
  semantically to the correct term.</span>
[^env-vs-chain]: In some contexts the term "environment" is taken to mean the
  entire environment chain.  In fact, the term "environment chain" is not a term
  used by the R documentation.
[^fun-create]: That is the default behavior, but is possible to change what the
  enclosing environment for any given function's evaluation environments will
  be with `environment(fun) <- `.  See also the discussion of [function
  evaluation environment terminology](#fun-env-term).
[^search-path]: Packages in R have multiple environments associated with them.
  We're hand-waving away distinctions between them, but they exist and are
  important.  Saruj Gupta's ["How R Searches and Finds Stuff"][29] is a
  must-read if you want to understand all the details.
[^name-vs-pkg]: Strictly speaking it is the base namespace environment, not the
  base package environment.
[^static-compile-funs]: `.Primitive`, `.Internal`, and a few other special
  R functions are entry points into the statically compiled machine code that
  actually does the work of computation.  Once those functions are invoked there
  is no more R code until they return, except if for some reason the statically
  compiled routines themselves invoke the internal version of `eval` or similar
  to evaluate R code.
[^closures]: Functions created with `function` in R are called "closures"
  because they have an enclosure.  There are other types of functions without
  such an environment.  These are called "builtin" or "special" functions.  They
  do not reference environments as they link directly to statically compiled
  code and do not need to look up names.
[^use-method]: It turns out `UseMethod` invokes one of those statically compiled
  routines.  It also so happens that routine does some frightful
  über-NSE, but we're just going to gloss over that business.  If you're really
  interested see `?UseMethod`.
[^fun-body]: The function "body" is the set of commands that follow the
  declaration.  In `function(...) {<function-body>}` the body is the set of
  commands that would replace the `<function-body>` placeholder.
[^value-copy]: R only copies objects when necessary to maintain the
  "pass-by-value" illusion.  See ["The Secret Lives Of R Objects"][31] for more
  details.
[^no-fun]: Environments can have multiple children [as we saw
  previously](#rev-chain).  While not shown here `fun`'s environment from
  earlier is still linked to the global environment.
[^par-vs-enc]: Unfortunately the terminology around the hierarchical
  relationship of environments in R is muddled.  In early days the term "parent"
  was used for enclosures, which is why `parent.env` returns the enclosure of an
  environment.  However, there is also the `parent.frame`, which is the
  evaluation environment of the command that that triggered the current
  evaluation.  The `parent.frame` is known as the "calling environment".
[^attached]: Packages loaded with `library`, or those that are part of the
  "base" set of packages that are pre-attache by R (e.g. `stats`, etc.), or any
  other environments attached with `attach`.



