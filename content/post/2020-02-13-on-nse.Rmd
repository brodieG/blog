---
title: On NSE
author: ~
date: '2020-02-13'
slug: on-nse
categories: []
tags: []
image: /front-img/default.png
imagerect: ~
imagemrgvt: 0%
imagemrghz: 0%
weight: 1
contenttype: article
description: Front page summary
output:
  blogdown::html_page:
    keep_md: yes
    md_extensions: +raw_attribute
---
```{r echo=FALSE, child='../../static/chunks/init.Rmd'}
```
# With Great Freedom...

<img
  id='front-img' src='/front-img/default.png'
  class='post-inset-image'
/>

Non-Standard Evaluation is a pretty controversial topic in R circles, and even
in the R documentation.  Whether you like it never, sometimes, or always, is
neither here nor there.  What matters is that R allows it.  Not many languages
give the programmer the power to implement, use, and abuse Non-Standard
Evaluation (NSE), or anything like it.

So what is NSE?  Very roughly, it is to programmatically modify a command or its
meaning after it is issued but before it is executed.  For example in:

```{r}
subset(mtcars, hp > 250)
```

The meaning of the command `hp > 300` is changed to be `mtcars$hp > 300`.  If
`subset` did not do this we would get an error as `hp` does not exist in my
workspace.

The objective of this post is to set down the bare minimum we need to know to
build a working mental of standard and non-standard evaluation.  We'll indulge
in approximations and otherwise gloss over important but secondary
details[^simple-model].

If you already understand how variable name resolution works in R, what
it means for unevaluated commands to be first-class objects, and what NSE does,
you are unlikely to find anything earth-shattering here.  For everyone else,
well, earth-shattering might be a wee exaggeration.

# Standard Evaluation

When we type a simple command at the R prompt and hit ENTER, R computes its
value a.k.a. "evaluates" it:

```{r echo=FALSE}
y <- c("am", "I", "why")
z <- c(1, 5, 9, 8)
```
```{r}
x <- c("am", "I", "global")
rev(x)           # reverse the order of vector `x`
```

<span id=two-things>R actually does two things after we hit ENTER:

1. Parses the command.
2. Evaluates it.

This is a fastidious distinction that is rarely noticed, but it is critical to
the functioning of NSE.  Parsing translates the command into a format that can
be more easily evaluated, and in the processes weeds out syntactically invalid
commands.  Evaluation then runs the command to produce the results.</span>

```{r eval=FALSE, echo=FALSE}
# code to generate flipbook images
source('static/script/mesh-viz/viz-lib.R')
png.in <- list.files(
  'static/post/2020-02-13-on-nse_files/templates/anim2',
  full.names=TRUE
)
png.dat <- lapply(png.in, png::readPNG)
png.a <- trim_png(png.dat[1:6], pad=c(10,10))
fname <- 'static/post/2020-02-13-on-nse_files/images/flip-1/img-%03d.png'
lapply(
  seq_along(png.a), function(x) png::writePNG(png.a[[x]], sprintf(fname, x))
)
ids <- 7:8
png.a <- trim_png(png.dat[ids], pad=c(10,10))
lapply(
  seq_along(ids), function(x) png::writePNG(png.a[[x]], sprintf(fname, ids[[x]]))
)
```

Commands in R are mostly made up of "words", which we'll call "names" for
consistency with the documentation[^mostly-names].  In the command `rev(x)` the
"names" are `rev`, and `x`[^parens].  To evaluate a parsed command, R must
first find the values or functions associated with the names.  This is done with
data structures called environments, shown in blue in this flipbook:

<div id='flipbook1'></div>

Mind the weapons grade hand-waving here, but this models observable behavior
reasonably well _for our purposes_[^promises].  R will search for each name
through a chain of environments.  <span id=eval-env>The first environment in the
environment chain is called the "evaluation environment"</span> and will be set
by the context the command is called in[^env-vs-chain].  For commands typed at
the prompt the evaluation environment is the global environment.

The object returned by the search is the one associated with the first instance
of each name in the environment chain[^not-object].  Once the evaluator has the
actual function and arguments it can run the function[^run-recursive], although
we omit that step here.

<span id='env-desc'>Environments are akin to named lists with a few additional
features.  All elements are uniquely named, and the names are usually indexed
with a [hash table][25] for fast lookups.  The mapping of names to objects
is called the "frame".  Additionally, environments carry a link to an
"enclosing" environment a.k.a. "enclosure".  In the diagram these links are
represented as arrows pointing to the enclosure.  This is how the chain is
implemented: when a name isn't found in an environment, R follows the link to
the enclosure and continues the search there and through subsequent enclosures
as needed.  An implication of this is the environment chain is defined
completely by the [evaluation environment](#eval-env)</span>

> **WARNING**: Environments have reference semantics.  Be sure you
> understand the [documentation][24] before you attempt to directly modify
> elements in environments, e.g. as in `env$name[3] <- 42`.


Since the global environment is the evaluation environment for prompt commands,
that is where name-object associations typed at the prompt are kept.  These
associations define "variables", but it's useful to distinguish between names
and the objects they are associated with, so we'll avoid the term "variable".
In the [flipbook](#flipbook1) we can see the object we associated with the name
`x`, along with another couple of associations for the names `y` and `z`.
`ls.str` confirms this:


```{r eval=FALSE}
ls.str()
```
```
x :  chr [1:3] "am" "I" "global"
y :  chr [1:3] "am" "I" "why"
z :  num [1:4] 1 5 9 8
```

What about the object associated with the name `rev`?  As we saw earlier it is
in a different environment called the base environment:

<img
  src='/post/2020-02-13-on-nse_files/images/flip-1/img-002.png'
  alt='Retrieving the rev function from the base environment.'
/>

We can ask `ls` to list objects from that environment, and confirm
that `rev` is indeed there:

```{r eval=FALSE}
ls(envir=baseenv())[928:932]
```
```
[1] "return"      "returnValue" "rev"         "rev.default" "rle"
```

There are many other environments between the global environment and the base
environment, though we do not use any names that would be resolved by them here.

> For a fantastic treatment of environments do read Saruj
> Gupta's ["How R Searches and Finds Stuff"][29].

# Masking

It is possible for different environments to contain the same name.  When this
happens the object returned is the one from the first environment along the
chain that contains that name.  Consider what happens if we nest our simple
`rev(x)` command in a trivial function:

<span id='fun'>
```{r}
fun <- function() {
  x <- c("am", "I", "fun")
  rev(x)
}
fun()
```
</span>

Most functions in R will create an environment when they are invoked to map
their names to objects in[^closures].  These function evaluation environments
normally have for enclosure the environment in which the function was
_created_[^fun-env-terminology].  For `fun` above that is the global
environment.

By running `rev(x)` inside of `fun` instead of directly at the prompt we changed
the active evaluation environment for `rev(x)` to be evaluation environment of
the function instead of the global environment as before.  This changes
environment chain the evaluator looks through:

<img
  src='/post/2020-02-13-on-nse_files/images/flip-1/img-007.png'
  alt='How a function environment modifies the environment chain.'
/>

The evaluator finds `x` in the function's evaluation environment instead of the
now-masked `x` in the global environment.

# Non-Standard Evaluation

Before we go on, a quick flash-back to standard evaluation:

```{r}
rev(x)
```

Consider instead:

```{r}
L <- list(x=c("am", "I", "list"))
with(
  L,
  rev(x)     # same commmand
)
```

What happened?  The names in `rev(x)` were matched against the list `L`.  In
fact, `with` converts `L` into an environment and adds it to the start of the
environment chain.  This is similar to what happened with [`fun` earlier](#fun),
except we didn't need to define a function.  That environments are [akin to
named lists](#env-desc) makes it particularly easy.

While the concept is straightforward the execution is more complicated.
`with` needs mechanisms for interrupting the evaluation, changing the
environment chain, and resuming evaluation.  R, being the strange language that
it is, provides tools to do all this.

Let's implement a version of `with` at the prompt to see what's going on:

```{r}
cmd  <- quote(rev(x))        # capture command
Lenv <- list2env(L)         # convert list to env
eval(cmd, envir=Lenv)       # invoke the evaluator
```

`quote` captures a parsed R command before the evaluator gets to it.  Once
captured the command no longer self-evaluates at the prompt:

```{r}
cmd    # we get command back, not result of evaluating it
```

We'll explore some more interesting implications of this in a bit, but for now
what we care about is that the evaluator is on hold.

`list2env` creates a new environment which has for enclosure the global environment
as that is where we called it from:

```{r}
Lenv
ls(Lenv)                    # list names
```
```{r}
parent.env(Lenv)
```

`eval` provides a mechanism to resume evaluation with a different environment
chain for name lookups:

```{r}
eval(cmd, envir=Lenv)
```

This is what the environment chain looks like now:

<img
  src='/post/2020-02-13-on-nse_files/images/flip-1/img-008.png'
  alt='Adding an environment to the environment chain with eval.'
/>

Environments can have multiple children.  While not shown here the `fun`'s
environment is still linked to the global environment.

Running `eval` without changing the starting environment produces the same result as if we had typed the command at the prompt:

```{r}
eval(cmd) # envir defaults to parent.frame (global here)
```

By changing the environment chain we made the evaluation "Non-Standard".

# In Functions

Compare:

```{r}
with(L, rev(x))
```

To our hack-at-the-prompt version:

```{r}
cmd  <- quote(rev(x))
Lenv <- list2env(L)
eval(cmd, envir=Lenv)
```

It would be nice to implement `with` ourselves, if we try to use `quote` inside
a function to get what someone types in as the argument to that function we are
disappointed:

```{r}
with2 <- function(dat, cmd) {
  quote(cmd)                 # capture command
  # rest of function will go here later
}
with2(L, rev(x))
```

What we want to quote is the command supplied argument `cmd`, not the name
`cmd`.  Thankfully R in its infinite flexibility provides a mechanism for doing
this with `substitute`:

```{r}
with2 <- function(dat, cmd) {
  substitute(cmd)
  # rest of function will go here later
}
with2(L, rev(x))
```

When called within a function on a function parameter, `substitute` acts like
`quote` except it substitutes the unevaluated command passed as the actual
parameter.  This allows us to implement `with`:

```{r}
with2 <- function(dat, cmd) {
  cmd2 <- substitute(cmd)
  denv <- list2env(dat, parent=parent.frame())
  eval(cmd2, envir=denv)
}
with2(L, rev(x))
```

We can do a bit better because `eval` supports adding a list-like element to the
environment chain out of the box:

```{r}
with2 <- function(L, cmd) {
  cmd2 <- substitute(cmd)
  eval(cmd2, L, enclos=parent.frame())
}
with2(L, rev(x))
```

What's the `parent.frame()` business?  And why do we pass it to the `enclos`
parameter for `eval`, but to the `parent`

# Environmental Dichotomy

`substitute` allows us to implement functions that perform NSE on their
arguments.  This is a powerful feature, but with it comes a new class of
potential errors.  Notice in our `with2` implementation how we call `eval`:

```{r}
```

Coincidentally this is the same environment we called the function from, but the
calling environment and the enclosing environment need not be the same.  For
example, when we call `rev(x)` directly at the prompt the calling environment is
the global environment, but the enclosing environment for `rev`'s evaluation
environment is the base environment.  This means that the lookup chain for names
within `rev` such as `UseMethod` essentially starts and ends at the base
environment[^base-not-end].


# A Lot of Rope




# First Class Language

So far all we've done with Non-Standard Evaluation is change the environment
chain.  We have not spent any time discussing one of the more remarkable
features of R: unevaluated commands are "first-class" objects, meaning they can
be manipulated directly.  For example we can edit commands by changing names it
contains:

```{r}
cmd <- quote(rev(x))
cmd
cmd[[2]] <- quote(y)
cmd
eval(cmd)
```

We can even do part of the evaluator's job by replacing names with objects:

```{r}
cmd[[1]] <- rev    # no 'quote' this time!
cmd[[2]] <- x
cmd
eval(cmd)
```

That looks [familiar](#flipbook1), right?

Unevaluated commands are stored as a type of list, which is why we can access
elements with the subset (`[[`) operator, and also why we can nest non-language
objects within them.  R just displays them as we're used to seeing them.

```{r}
cmd  <- quote(rev(x))
typeof(cmd)
str(as.list(cmd))    # show list nature of cmd
```

We used this feature in a [previously post][28] to implement a Reverse Polish
Notion calculator in R.

R gives us the ability to 

# Why

Saving keystrokes.

# Topic List


* [Survey of Macros in R][22]
* [R NSE Reference][27]
* [Tips on NSE in R][28] by Kun Ren

# Conclusions

<!-- this needs to become a shortcode -->
<!-- this is populated by JS in feedback.html partial -->
<p id='feedback-cont'></p>

# Appendix

## Acknowledgments

* png

## Session Info

<!--
```{r child='../../static/script/_lib/zoom-img/zoom-img.Rmd', results='asis', cache=FALSE}
```
-->
```{r child='../../static/script/_lib/flipbook/flipbook.Rmd', results='asis', cache=FALSE}
```
<script type='text/javascript'>
const imgDir = '/post/2020-02-13-on-nse_files/images/flip-1/';
const fps = 1;
new BgFlipBook({
  targetId: 'flipbook1', imgDir: imgDir, imgStart: 1, imgEnd: 6,
  imgPad: "000", fps: fps, loop: true
})
</script>

[20]: https://cran.r-project.org/doc/manuals/R-lang.html#Argument-evaluation
[21]: https://stat.ethz.ch/R-manual/R-devel/library/compiler/html/compile.html
[23]: https://github.com/WinVector/wrapr/blob/master/extras/MacrosInR.md
[24]: https://cran.r-project.org/doc/manuals/R-lang.html#Environment-objects
[25]: https://en.wikipedia.org/wiki/Hash_table
[26]: http://blog.obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/
[27]: http://developer.r-project.org/nonstandard-eval.pdf
[28]: /2019/01/11/reverse-polish-notation-parsing-in-r/
[29]: https://renkun.me/2014/12/03/tips-on-non-standard-evaluation-in-r/

[^simple-model]: <span id='simple-model'>Items we gloss over include but are not
  limited to:<ul>
  <li>Function parameters are [evaluated lazily][20] so they are only fetched
  when they are referenced within a function body.
  <li>The [byte-compiler][21] affects the nature of non-evaluated code
  prefetching objects names point to and performing other optimizations.
  <li>Names representing called functions are only resolved against names that
  are associated with functions.
  <li>Lookups from the global environment down are usually done against a
  "global" hash table that replicates the semantics of the environment chain,
  but isn't actually a chain.
  <li>The base environment has an enclosure, although it is the empty
  environment which itself does not have an enclosure.
  <li>And more.</ul></span>
[^mostly-names]: In R "names" are not restricted to words in the typical sense.
  Symbols like `*`, `+`, and even `(` in some circumstances are also called
  "names".  "names" are also called "symbols" and the terms are often used
  interchangeably in the documentation.
[^parens]: The parentheses in `rev(x)` are not considered "names".  They are
  syntax tokens that are used to parse the command.  Opening parentheses that
  are not part of the syntax of a function call are names, as in `(1 + 2) * 3`.
[^run-recursive]: Where by "run the function" means retrieving the body of the
  function, and repeating the fetching we just went through, until eventually we
  start hitting statically compiled functions invoked via `.Primitive`,
  `.Internal`, and similar, when the actual computation occurs.  All the
  [aforementioned caveats](#simple-model) still apply, in particular that names
  are not actually substituted until they are used in a function body.
[^promises]: The most substantive inaccuracy is that arguments are only
  substituted until they are used in the function body, not when the function is
  called.
[^not-object]: What's actually returned is a pointer to the location in memory
  the object is located at.  Since in R memory addresses are not directly
  visible, we'll pretend the actual objects instead of just pointers to them are
  returned.
[^fun-env-terminology]: For reasons unclear to me the documentation refers to
  the enclosing environment of the function evaluation environment as the
  "function environment" instead of the enclosing environment which seems much
  more natural to me.  Maybe because it needs to be called the "environment to
  be used as the enclosure of the function evaluation environment" to be
  technically correct?
[^env-vs-chain]: In some context the term "environment" is taken to mean the
  entire environment chain.  In fact, the term "environment chain" is not a term
  used by the R documentation.

