---
title: On NSE
author: ~
date: '2020-02-13'
slug: on-nse
categories: []
tags: []
image: /front-img/default.png
imagerect: ~
imagemrgvt: 0%
imagemrghz: 0%
weight: 1
contenttype: article
description: Front page summary
output:
  blogdown::html_page:
    keep_md: yes
    md_extensions: +raw_attribute
---
```{r echo=FALSE, child='../../static/chunks/init.Rmd'}
```
# With Great Freedom...

<img
  id='front-img' src='/front-img/default.png'
  class='post-inset-image'
/>

Non-Standard Evaluation is a pretty controversial topic in R circles, and even
in the R documentation.  Whether you like it never, sometimes, or always, is
neither here nor there.  What matters is that R allows it.  Not many languages
give the programmer the power to implement, use, and abuse Non-Standard
Evaluation (NSE), or anything like it.

So what is NSE?  Very roughly, it is to programmatically modify a command or its
meaning after it is issued but before it is executed.  For example in:

```{r}
subset(mtcars, hp > 250)
```

The meaning of the command `hp > 300` is changed such that the column `hp` from
`mtcars` is used as `hp`.  If `subset` did not do this we would get an error as
`hp` does not exist in my workspace.

NSE is quite widespread in R.  It shows up in places we don't normally think of
as being special, such as in commands like `library(Rcpp)` or even `mtcars$hp`.
It is also used to great effect by third party packages like `data.table` and
`dplyr`.

The objective of this post is to set down the minimum we need to know for a
useful mental model of standard and non-standard evaluation.  We'll indulge in
approximations and otherwise gloss over important but secondary
details[^simple-model].  Maybe I'll throw in some not-strictly-necessary but
interesting tidbits I can't suppress.

If you already understand how variable name resolution works in R, what
it means for unevaluated commands to be first-class objects, and what NSE does,
you are unlikely to find anything earth-shattering here.  For
everyone else, well, you too are unlikely to find anything earth-shattering.
Sorry.

# Standard Evaluation

When we type a simple command at the R prompt and hit ENTER, R computes its
value a.k.a. "evaluates" it:

```{r echo=FALSE}
y <- c("am", "I", "why")
z <- c(1, 5, 9, 8)
```
```{r}
w <- c("am", "I", "global")
rev(w)           # reverse the order of vector `x`
```

<span id=two-things>R actually does two things after we hit ENTER:

1. Parses the command.
2. Evaluates it.

This is a fastidious distinction that is rarely noticed, but as we'll see later
it is critical to the functioning of NSE.  Parsing translates the command into a
format that can be more easily evaluated, and in the processes weeds out
syntactically invalid commands.  Evaluation then runs the command to produce the
results.</span>

```{r eval=FALSE, echo=FALSE}
# code to generate flipbook images
source('static/script/mesh-viz/viz-lib.R')
png.in <- list.files(
  'static/post/2020-02-13-on-nse_files/templates/anim3',
  full.names=TRUE
)
png.dat <- lapply(png.in, png::readPNG)
png.a <- trim_png(png.dat[1:6], pad=c(10,10))
fname <- 'static/post/2020-02-13-on-nse_files/images/flip-1/img-%03d.png'
lapply(
  seq_along(png.a), function(x) png::writePNG(png.a[[x]], sprintf(fname, x))
)
ids <- 7:9
png.a <- unlist(lapply(
  png.dat[ids], function(x, pad) trim_png(list(x), pad=pad), pad=c(10,10)
), recursive=FALSE)
lapply(
  seq_along(ids), function(x) png::writePNG(png.a[[x]], sprintf(fname, ids[[x]]))
)
```

Commands in R are mostly made up of "words", which we'll call "names" for
consistency with the documentation[^mostly-names].  In the command `rev(x)` the
"names" are `rev`, and `x`[^parens].  To evaluate a parsed command, R must
first find the values or functions associated with the names.  This is done with
data structures called environments, shown in blue in this flipbook:

<div id='flipbook1'></div>

<span id='env-desc'>Environments are akin to named lists with a few additional
features.  All elements are uniquely named, and the names are usually indexed
with a [hash table][25] for fast lookups.  The mapping of names to objects
is called the "frame" (blue boxes in the diagrams).  Additionally, environments
carry a link to an "enclosing" environment a.k.a. "enclosure" (black arrows in
the diagram, pointing to enclosure).  R searches for a name in an environment's
frame, and if it doesn't find it it moves on to the enclosure repeating the
process until the name is found or it runs out of enclosures.</span>

<span id=ref-sem-warn>
> **WARNING**: Environments have reference semantics.  Be sure you
> understand the [documentation][24] before you attempt to directly modify
> elements in environments, e.g. as in `env$name[3] <- 42`.
</span>

<span id=eval-env>The first environment in the environment chain is called the
"evaluation environment"[^env-vs-chain]</span>, and because the chain never
forks it dictates how all names in a command are found.

Once the names have been substituted with the objects they point to, R can run
the retrieved function (`rev` here).  Be advised there is some weapons-grade
hand-waving going on at the moment[^weapons-grade].  Functions[^closures], like
environments, also carry a link to an environment[^fun-env-terminology].
Usually it is the package environment they belong to[^search-path], or the
evaluation environment they are created in[^fun-create].

<span id=fun-eval-env>Prior to running a function, R creates a new environment
and assigns the function's environment as its enclosure.  We'll call this new
environment the function's **evaluation** environment, not to be confused with
the **function** environment that is used as its enclosure (yes this terminology
is unforgiving).  R populates the function **evaluation** environment with the
provided arguments and evaluates each command of the function body
therein[^fun-body].  `rev` only has one command in its body:</span>

```{r}
body(rev)
```

Let's illustrate the environment chain for evaluation of the body of `rev`.
We show the one command on the left, and the chain starting with `rev`'s
evaluation environment (`<rev>` in the diagram) on the right:

<img
  id=rev-chain
  src='/post/2020-02-13-on-nse_files/images/flip-1/img-007.png'
  alt='The environment chain for the rev function.'
/>

In `<rev>` we have the name `x` corresponding to its one argument.  It is
associated to the same value[^value-copy] as `w` from the global environment
because the original call `rev(w)` was evaluated in the global environment.  The
previous environment chain shown in the background still exists but it's
inactive at the moment.

Now that the new evaluation environment is set we proceed with the same name
substitution [observed previously](#flipbook1).  `UseMethod` will be retrieved
from the base environment (not shown, but it's there I promise), and it will be
"run" just as `rev` was.  The substitute-then-"run" process continues
recursively until we hit statically compiled code routines invoked by
`.Primitive`, `.Internal`, etc., at which point the actual computations
occur[^use-method].  Ironically this means the R evaluator itself doesn't do any
evaluating.  It just substitutes names with objects[^not-object], sets up
environment chains, and recurses.

Important take-aways from this section:

1. Commands acquire their meaning when the names therein are substituted with
   objects the they reference.
2. Names are resolved to objects by looking them up through environment chains.
3. The environment chain, and hence the meaning of commands, is set by the
   environment in which the command is evaluated.

> For a more complete treatment of environments and how they are used by R do
> read Saruj Gupta's ["How R Searches and Finds Stuff"][29].

# Masking

It is possible for different environments to contain the same name.  When this
happens the object returned is the one from the first environment along the
chain that contains that name.  Consider what happens if we nest our simple
`rev(x)` command in a trivial function:

<span id='fun'>
```{r}
fun <- function() {
  w <- c("am", "I", "fun")
  rev(w)
}
fun()
```
</span>

As we saw [earlier](#fun-eval-env), R will create an evaluation environment to
evaluate the body of `fun`.  Since `fun` was created in the global environment,
that will be the enclosure for the function evaluation environment.  As a
result, by running `rev(w)` inside of `fun` instead of directly at the prompt we
changed the evaluation environment for the command.  This is what the
environment chain looks like now:

<img
  src='/post/2020-02-13-on-nse_files/images/flip-1/img-008.png'
  alt='How a function environment modifies the environment chain.'
/>

The evaluator finds `w` in the function's evaluation environment instead of the
now-masked `w` in the global environment and so substitutes a different value
for it.

# Non-Standard Evaluation

Before we go on, a quick flash-back to standard evaluation:

```{r}
rev(w)
```

Consider instead:

```{r}
L <- list(w=c("am", "I", "list"))
with(
  L,
  rev(w)     # same commmand
)
```

What happened?  The names in `rev(w)` were matched against the list `L`.  In
other words `L` masked the name search as [`fun`'s evaluation environment
did](#fun), except we didn't need to define a function.

While the concept is straightforward the execution is more complicated.
`with` needs mechanisms for interrupting the evaluation, masking the
active environment chain in some way with `L`, and resuming evaluation.  R,
being the strange language that it is, provides tools to do all this.

Let's implement a version of `with` at the prompt to see how this might be
done:

```{r}
cmd  <- quote(rev(w))       # capture command
Lenv <- list2env(L)         # convert list to env
eval(cmd, envir=Lenv)       # invoke the evaluator
```

`quote` captures a parsed R command before the evaluator gets to it.  Once
captured the command no longer self-evaluates at the prompt, that is if you type
it at the prompt you get the unsubstituted, un-run command back:

```{r}
cmd    # we get command back, not result of evaluating it
```

It may not seem like much, but it's a big deal R allows this.  Commands when
quoted as we did here are first class objects.  We'll explore some more
interesting implications of this in a bit, but for now what we care about is
that the evaluator is on hold.

`list2env` creates a new environment which has for enclosure the global
environment as that is where we called it from.  This is possible because
environments are [akin to named lists](#env-desc).

```{r}
Lenv
ls.str(Lenv)
```
```{r}
parent.env(Lenv)   # parent.env == enclosure
```

`eval` provides a mechanism to resume evaluation with a different environment
chain for name lookups:

```{r}
eval(cmd, envir=Lenv)
```

This is what the environment chain looks like now right before substituting the
`w` name[^no-fun]:

<img
  src='/post/2020-02-13-on-nse_files/images/flip-1/img-009.png'
  alt='Adding an environment to the environment chain with eval.'
/>

> By changing the environment chain we made the evaluation "Non-Standard".


Running `eval` without changing the starting environment produces the same result as if we had typed the command at the prompt:

```{r}
eval(cmd) # envir defaults to parent.frame (global here)
```

Now look at what happens if we make a new mask that contains a `rev` symbol as
well:

```{r}
L2 <- list(rev=toupper)
L2env <- list2env(L2, parent=Lenv)
eval(cmd, envir=L2env)
```

We can change the meaning of functions as well as values by modifying the
environment chain.  Notice how we set the enclosure to `L2env` to be `Lenv` with
the `parent` parameter to `list2env`[^par-vs-enc].  We could also have directly
added a `rev` mapping to `Lenv`, but recall the warning about [environment
reference semantics](#ref-sem-warn).

Manipulating the environment chain is not the only way to perform NSE.  Anything
that changes the meaning of a command after it is issued relative to what would
have happened in standard evaluation is NSE.

# In Functions

Compare:

```{r}
with(L, rev(w))
```

To our hack-at-the-prompt version:

```{r}
cmd  <- quote(rev(w))
Lenv <- list2env(L)
eval(cmd, envir=Lenv)
```

It would be nice to implement `with` ourselves, if we try to use `quote` inside
a function to get what someone types in as the argument to that function we are
disappointed:

```{r}
with2 <- function(dat, cmd) {
  quote(cmd)                 # capture command
  # rest of function will go here later
}
with2(L, rev(w))
```

What we want to quote is the command supplied argument `cmd`, not the name
`cmd`.  Thankfully R in its infinite flexibility provides a mechanism for doing
this with `substitute`:

```{r}
with2 <- function(dat, cmd) {
  substitute(cmd)
  # rest of function will go here later
}
with2(L, rev(w))
```

When called within a function on a function parameter, `substitute` acts like
`quote` except it substitutes the unevaluated command passed as the actual
parameter.  This allows us to implement `with`:

```{r}
with2 <- function(dat, cmd) {
  cmd2 <- substitute(cmd)
  denv <- list2env(dat, parent=parent.frame())
  eval(cmd2, envir=denv)
}
with2(L, rev(w))
```

We can do a bit better because `eval` supports adding a list-like element to the
environment chain out of the box:

```{r}
with2 <- function(L, cmd) {
  cmd2 <- substitute(cmd)
  eval(cmd2, L, enclos=parent.frame())
}
with2(L, rev(w))
```

What's the `parent.frame()` business?  And why do we pass it as the `enclos`
argument for `eval`, but as the argument `parent` for `list2env`?

# Environmental Dichotomy

`substitute` allows us to implement functions that perform NSE on their
arguments.  This is a powerful feature, but with it comes a new class of
potential errors.  Notice in our `with2` implementation how we call `eval`:

```{r eval=FALSE}
eval(cmd2, L, enclos=parent.frame())
```

Recall that in R the evaluation process is recursive.  Additionally, note that
in R every evaluated command is actually a function
invocation[^every-cmd-is-fun].  Even commands that don't look like functions are
functions:

```{r}
is.function(`+`)
`+`(1, 1)
is.function(`if`)
`if`(2 > 1, 'truth', 'falsehood')
```

The behavior of function invocations (a.k.a. function calls) is to evaluate
arguments in the environment the call is made, but then to evaluate the body
of the function in the function **evaluation** environment[^non-default].  For
clarity we'll call the environment in which the function call is made the
**calling** environment.  This distinction may appear particularly fastidious
especially when we're used to creating functions in the global environment.
After all when we do that the enclosure to our function **evaluation**
environment is often the **calling** environment.  Consider a bad version of
`with2` that doesn't specify the calling environment as the enclosure:

```{r}
with2_bad <- function(L, cmd) {
  cmd2 <- substitute(cmd)
  eval(cmd2, L)
}
with2_bad(L, rev(w))
```

No problem right?  Except look at what happens with a pathological input:

```{r}
cmd2 <- c("pathological", "I", "am")
with2_bad(L, rev(cmd2))
```

Wow, what the heck is that?  It is the result of:

```{r}
rev(quote(rev(cmd2)))
```

The key thing to realize is that we had a name clash.  The `cmd2` symbol
associated in `with2_bad`'s **evaluation** environment masks the `cmd2` in the
**calling** environment  By changing the enclosure for the `eval` call as our
original `with2` all the names are resolved properly:

```{r}
cmd2 <- c("pathological", "I", "am")
with2(L, rev(cmd2))
```

No, you're not pathological, not anymore.

This is a contrived example as it requires the function doing NSE to have names
that mask those used in the captured call, but there are other ways things go
wrong.  If our function were called from within another function, then the names
might not resolve at all, or resolve to the wrong object:


```{r}
friendly_fun <- function(L) {
  z <- c('hello', 'friend', '!')
  with2_bad(L, paste(c(z, w), collapse=' '))
}
friendly_fun(L)
```

What happened?  Instead of using the `z` in `fun2`'s evaluation environment,
which in this case is `with2_bad`'s **calling** environment, we used the `z` in
the global environment.  Why?  Because the `with2_bad`'s **function**
environment, and hence the enclosure of it's **evaluation** environments, is the
global environment.  Again, this is resolved by explicitly setting the
evaluation enclosure to the **calling** frame with `parent.frame` as `with2`
does:

```{r}
friendly_fun <- function(L) {
  z <- c('hello', 'friend', '!')
  with2(L, paste(c(z, w), collapse=' '))
}
friendly_fun(L)
```


If we were to put our function in a package then there will
the possibility of a
name collision increases substantially

s rare to change function
environments in this way.  However, if you put functions in packages, or create
functions within other functions, or simply use functions in NSE contexts, it is
easy to end up in situations where the calling environment and the enclosure of
the function evaluation environment (i.e. the function environment) diverge.




The
important thing here is that the


Every time a command is
evaluated




Coincidentally this is the same environment we called the function from, but the
calling environment and the enclosing environment need not be the same.  For
example, when we call `rev(x)` directly at the prompt the calling environment is
the global environment, but the enclosing environment for `rev`'s evaluation
environment is the base environment.  This means that the lookup chain for names
within `rev` such as `UseMethod` essentially starts and ends at the base
environment[^base-not-end].


# A Lot of Rope




# First Class Language

So far all we've done with Non-Standard Evaluation is change the environment
chain.  We have not spent any time discussing one of the more remarkable
features of R: unevaluated commands are "first-class" objects, meaning they can
be manipulated directly.  For example we can edit commands by changing names it
contains:

```{r}
cmd <- quote(rev(x))
cmd
cmd[[2]] <- quote(y)
cmd
eval(cmd)
```

We can even do part of the evaluator's job by replacing names with objects:

```{r}
cmd[[1]] <- rev    # no 'quote' this time!
cmd[[2]] <- x
cmd
eval(cmd)
```

That looks [familiar](#flipbook1), right?

Unevaluated commands are stored as a type of list, which is why we can access
elements with the subset (`[[`) operator, and also why we can nest non-language
objects within them.  R just displays them as we're used to seeing them.

```{r}
cmd  <- quote(rev(x))
typeof(cmd)
str(as.list(cmd))    # show list nature of cmd
```

We used this feature in a [previously post][28] to implement a Reverse Polish
Notion calculator in R.

R gives us the ability to

# Why

Saving keystrokes.

# Topic List


* [Survey of Macros in R][22]
* [R NSE Reference][27]
* [Tips on NSE in R][28] by Kun Ren
* [Original R Paper][30]

# Conclusions

<!-- this needs to become a shortcode -->
<!-- this is populated by JS in feedback.html partial -->
<p id='feedback-cont'></p>

# Appendix

## Acknowledgments

Sumner.

* png

## Session Info

<!--
```{r child='../../static/script/_lib/zoom-img/zoom-img.Rmd', results='asis', cache=FALSE}
```
-->
```{r child='../../static/script/_lib/flipbook/flipbook.Rmd', results='asis', cache=FALSE}
```
<script type='text/javascript'>
const imgDir = '/post/2020-02-13-on-nse_files/images/flip-1/';
const fps = 1;
new BgFlipBook({
  targetId: 'flipbook1', imgDir: imgDir, imgStart: 1, imgEnd: 6,
  imgPad: "000", fps: fps, loop: true
})
</script>

[20]: https://cran.r-project.org/doc/manuals/R-lang.html#Argument-evaluation
[21]: https://stat.ethz.ch/R-manual/R-devel/library/compiler/html/compile.html
[23]: https://github.com/WinVector/wrapr/blob/master/extras/MacrosInR.md
[24]: https://cran.r-project.org/doc/manuals/R-lang.html#Environment-objects
[25]: https://en.wikipedia.org/wiki/Hash_table
[26]: http://blog.obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/
[27]: http://developer.r-project.org/nonstandard-eval.pdf
[28]: /2019/01/11/reverse-polish-notation-parsing-in-r/
[29]: https://renkun.me/2014/12/03/tips-on-non-standard-evaluation-in-r/
[30]: https://www.stat.auckland.ac.nz/~ihaka/downloads/R-paper.pdf
[82]: /2019/02/18/an-unofficial-reference-for-internal-inspect/

[^earth-shattering]: Under no circumstances
[^more-complicated]: The actual meaning changes is more complicated, but we'll
  discuss that in the body of this post.
[^simple-model]: <span id='simple-model'>Items we gloss over include but are not
  limited to:<ul>
  <li>Function parameters are [evaluated lazily][20] so they are only fetched
  when they are referenced within a function body.
  <li>The [byte-compiler][21] affects the nature of non-evaluated code
  prefetching objects names point to and performing other optimizations.
  <li>Names representing called functions are only resolved against names that
  are associated with functions.
  <li>Lookups from the global environment down are usually done against a
  "global" hash table that replicates the semantics of the environment chain,
  but isn't actually a chain.
  <li>The base environment has an enclosure, although it is the empty
  environment which itself does not have an enclosure.
  <li>And more.</ul></span>
[^mostly-names]: In R "names" are not restricted to words in the typical sense.
  Symbols like `*`, `+`, and even `(` in some circumstances are also called
  "names".  "names" are also called "symbols" and the terms are often used
  interchangeably in the documentation.
[^parens]: The parentheses in `rev(x)` are not considered "names".  They are
  syntax tokens that are used to parse the command.  Opening parentheses that
  are not part of the syntax of a function call are names, as in `(1 + 2) * 3`.
[^run-recursive]: Where by "run the function" means retrieving the body of the
  function, and repeating the fetching we just went through, until eventually we
  start hitting statically compiled functions invoked via `.Primitive`,
  `.Internal`, and similar, when the actual computation occurs.  All the
  [aforementioned caveats](#simple-model) still apply, in particular that names
  are not actually substituted until they are used in a function body.
[^weapons-grade]: In reality the names are not substituted in place as we show
  here.  R will hold the function and a list of the arguments encapsulated as
  promises which it can then use to evaluate the body of the function.  Because
  the arguments are kept as promises they are not actually substituted until
  they are used in the body of the function, or in those of subsequent functions
  that they are forward to, or not all if they are not used.  However, in most
  cases were the argument is used and evaluating it does not cause side-effects,
  the observed behavior is as if the names had been substituted in place, or at
  least in place in a copy of the list.
[^not-object]: What's actually returned is a pointer to the location in memory
  the object is located at.  Since in R memory addresses are not directly
  visible, we'll pretend the actual objects instead of just pointers to them are
  returned.
[^fun-env-terminology]: <span id=fun-env>I find the idea of the "function
  environment" very confusing.  I think a better name would be "function
  enclosure".  Yes, strictly speaking the function does not have an enclosure,
  it is the function evaluation environments that do.  But by calling the
  function environment "function enclosure" we avoid ambiguity with the
  "function **evaluation** environment".  Additionally, it seems pretty natural
  to me for the "function enclosure" to be the enclosure of the function
  **evaluation** environment.  Technically the "function environment" is the
  "environment to be used as the enclosure of the function evaluation
  environment", and "function environment" captures that no better than
  "function enclosure"</span>
[^env-vs-chain]: In some contexts the term "environment" is taken to mean the
  entire environment chain.  In fact, the term "environment chain" is not a term
  used by the R documentation.
[^fun-create]: That is the default behavior, but is possible to change what the
  enclosing environment for any given function's evaluation environments will
  be with `environment(fun) <- `.  See also the discussion of [function
  evaluation environment terminology](#fun-env).
[^search-path]: Packages in R have multiple environments associated with them.
  We're hand-waving away distinctions between them, but they exist and are
  important.  Saruj Gupta's ["How R Searches and Finds Stuff"][29] is a
  must-read if you want to understand all the details.
[^name-vs-pkg]: Strictly speaking it is the base namespace environment, not the
  base package environment.
[^closures]: Functions created with `function` in R are called "closures"
  because they carry the reference to the environment they were created in.
  There are other types of functions without such an environment.  These are
  called "builtin" or "special" functions.  They do not reference environments
  as they link directly to statically compiled code and do not need to look up
  names.
[^use-method]: It turns out `UseMethod` invokes one of those statically compiled
  routines.  It also so happens that routine does some frightful
  uber-non-standard-evaluation, but we're just going to gloss over that
  business.  If you're really interested see `?UseMethod`.
[^fun-body]: The function "body" is the set of commands that follow the
  declaration.  In `function(...) {<function-body>}` the body is the set of
  commands that would replace the `<function-body>` placeholder.
[^value-copy]: R only copies objects when necessary to maintain the
  "pass-by-value" illusion.  See ["The Secret Lives Of R Objects"][31] for more
  details.
[^no-fun]: Environments can have multiple children [as we saw
  previously](#rev-chain).  While not shown here `fun`'s environment from
  earlier is still linked to the global environment.
[^par-vs-enc]: Unfortunately the terminology around the hierarchical
  relationship of environments in R is muddled.  In early days the term "parent"
  was used for enclosures, which is why `parent.env` returns the enclosure of an
  environment.  However, there is also the `parent.frame`, which is the
  evaluation environment of the command that that triggered the current
  evaluation.  The `parent.frame` is known as the "calling environment".



