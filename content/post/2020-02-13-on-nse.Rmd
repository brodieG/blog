---
title: On NSE
author: ~
date: '2020-02-13'
slug: on-nse
categories: []
tags: []
image: /front-img/default.png
imagerect: ~
imagemrgvt: 0%
imagemrghz: 0%
weight: 1
contenttype: article
description: Front page summary
output:
  blogdown::html_page:
    keep_md: yes
    md_extensions: +raw_attribute
---
```{r echo=FALSE, child='../../static/chunks/init.Rmd'}
```
# With Great Freedom...

<img
  id='front-img' src='/front-img/default.png'
  class='post-inset-image'
/>

Non-Standard Evaluation is a pretty controversial topic in R circles, and even
in the R documentation.  Whether you like it never, sometimes, or always, is
neither here nor there.  What matters is that R allows it.  Not many languages
give the programmer the power to implement, use, and abuse Non-Standard
Evaluation (NSE), or anything like it.

So what is NSE?  Very roughly, it is to programmatically modify a command or its
meaning after it is issued but before it is executed.  For example in:

```{r}
subset(mtcars, hp > 250)
```

The meaning of the command `hp > 300` is changed such that the column `hp` from
`mtcars` is used as `hp`.  If `subset` did not do this we would get an error as
`hp` does not exist in my workspace.

# Standard Evaluation

When we type a simple command at the R prompt and hit ENTER, R computes its
value a.k.a. "evaluates" it:

```{r echo=FALSE}
y <- c("am", "I", "why")
z <- c(1, 5, 9, 8)
```
```{r}
w <- c("am", "I", "global")
rev(w)           # reverse the order of vector `x`
```

<span id=two-things>R actually does two things after we hit ENTER:

1. Parses the command.
2. Evaluates it.

As we'll see later this rarely-noticed distinction is critical to the
functioning of NSE.  Parsing translates the command into a format that can be
more easily evaluated, and in the processes weeds out syntactically invalid
commands.  Evaluation then runs the command to produce the
results.</span>

```{r eval=FALSE, echo=FALSE}
# code to generate flipbook images
source('static/script/mesh-viz/viz-lib.R')
png.in <- list.files(
  'static/post/2020-02-13-on-nse_files/templates/anim4',
  full.names=TRUE
)
png.dat <- lapply(png.in, png::readPNG)
png.a <- trim_png(png.dat[1:6], pad=c(10,10))
fname <- 'static/post/2020-02-13-on-nse_files/images/flip-1/img-%03d.png'
lapply(
  seq_along(png.a), function(x) png::writePNG(png.a[[x]], sprintf(fname, x))
)

ids <- 7:13
png.a <- trim_png(png.dat[ids], pad=c(10,10))
lapply(
  seq_along(ids), function(x) png::writePNG(png.a[[x]], sprintf(fname, ids[[x]]))
)

ids <- 14:15
png.a <- unlist(lapply(
  png.dat[ids], function(x, pad) trim_png(list(x), pad=pad), pad=c(10,10)
), recursive=FALSE)
lapply(
  seq_along(ids), function(x) png::writePNG(png.a[[x]], sprintf(fname, ids[[x]]))
)
```

Commands in R are mostly made up of "words", which we'll call "names" for
consistency with the documentation[^mostly-names].  In the command `rev(x)` the
"names" are `rev`, and `x`[^parens].  To evaluate a parsed command, R must
first find the values or functions associated with the names.  This is done with
data structures called environments, shown in blue in this flipbook:

<div id='flipbook1'></div>

<span id='env-desc'>Environments are akin to named lists with a few additional
features.  All elements are uniquely named, and the names are usually indexed
with a [hash table][25] for fast lookups.  The mapping of names to objects
is called the "frame".  Additionally, environments carry a link to an
"enclosing" environment a.k.a. "enclosure" (black arrows in the diagram,
pointing to enclosure).  R searches for a name in an environment's frame, and if
it doesn't find it it moves on to the enclosure repeating the process until the
name is found or it runs out of enclosures.</span>

> **WARNING**: Environments have reference semantics.  Be sure you
> understand the [documentation][24] before you attempt to directly modify
> elements in environments, e.g. as in `env$name[3] <- 42`.

<span id=eval-env>The first environment in the environment chain is called the
"evaluation environment"[^env-vs-chain]</span>, and because the chain never
forks it dictates how all names in a command are found.  Once the names have
been substituted with the objects they point to, R can run the retrieved
function (`rev` here).  Be advised there is some weapons-grade hand-waving going
on at the moment[^weapons-grade].

Before we can discuss "running a function", we need to describe functions in
more detail.  Like environments, functions have enclosures[^closures].  Strictly
speaking the function enclosure is known as the "function environment", but
"function enclosure" is a better term for it[^fun-env-term].  Usually the
function enclosure is the package environment the function belongs
to[^search-path], or the evaluation environment the function was created
in[^fun-create].

<span id=fun-eval-env>Prior to running a function, R creates a new environment
with the function enclosure as its enclosure.  We'll call this new environment
the function's **evaluation** environment.  R then populates this environment
with the provided arguments.  Finally, it evaluates each command of the function
body therein[^fun-body].  

`rev` only has one command in its body:

```{r}
body(rev)
```

Let's step through the process:

<div id='flipbook2'></div>



In `<rev>` we have the name `x` corresponding to its one argument.  It is
associated to the same value[^value-copy] as `w` from the global environment
because the original call `rev(w)` was evaluated in the global environment.  The
previous environment chain shown in the background still exists but it's
inactive at the moment.

Now that the new evaluation environment is set we proceed with the same name
substitution [observed previously](#flipbook1).  `UseMethod` will be retrieved
from the base environment (not shown, but it's there I promise), and it will be
"run" just as `rev` was.  The substitute-then-"run" process continues
recursively until we hit statically compiled code routines invoked by
`.Primitive`, `.Internal`, etc., at which point the actual computations
occur[^use-method].  Ironically this means the R evaluator itself doesn't do any
evaluating.  It just substitutes names with objects[^not-object], sets up
environment chains, and recurses.

Important take-aways from this section:

1. Commands acquire their meaning when the names therein are substituted with
   objects the they reference.
2. Names are resolved to objects by looking them up through environment chains.
3. The environment chain, and hence the meaning of commands, is set by the
   environment in which the command is evaluated.

> For a more complete treatment of environments and how they are used by R do
> read Saruj Gupta's ["How R Searches and Finds Stuff"][29].

# Masking

It is possible for different environments to contain the same name.  When this
happens the object returned is the one from the first environment along the
chain that contains that name.  Consider what happens if we nest our simple
`rev(x)` command in a trivial function:

<span id='fun'>
```{r}
fun <- function() {
  w <- c("am", "I", "fun")
  rev(w)
}
fun()
```
</span>

As we saw [earlier](#fun-eval-env), R will create an evaluation environment to
evaluate the body of `fun`.  Since `fun` was created in the global environment,
that will be the enclosure for the function evaluation environment.  As a
result, by running `rev(w)` inside of `fun` instead of directly at the prompt we
changed the evaluation environment for the command.  This is what the
environment chain looks like now:

<img
  src='/post/2020-02-13-on-nse_files/images/flip-1/img-014.png'
  alt='How a function environment modifies the environment chain.'
/>

The evaluator finds `w` in the function's evaluation environment instead of the
now-masked `w` in the global environment and so substitutes a different value
for it.

# Non-Standard Evaluation

Before we go on, a quick flash-back to standard evaluation:

```{r}
rev(w)
```

Consider instead:

```{r}
L <- list(w=c("am", "I", "list"))
with(
  L,
  rev(w)     # same commmand
)
```

What happened?  The names in `rev(w)` were matched against the list `L`.  In
other words, `L` masked the name search as [`fun`'s evaluation environment
did](#fun), except we didn't need to define a function.

While the concept is straightforward the execution is more complicated.
`with` needs mechanisms for interrupting the evaluation, masking the
active environment chain in some way with `L`, and resuming evaluation.  R,
being the strange language that it is, provides tools to do all this.

Let's implement a version of `with` at the prompt to see how this might be
done:

```{r}
cmd  <- quote(rev(w))       # capture command
Lenv <- list2env(L)         # convert list to env
eval(cmd, envir=Lenv)       # invoke the evaluator
```

`quote` captures a parsed R command before the evaluator gets to it.  Once
captured the command no longer self-evaluates at the prompt, that is if you type
it at the prompt you get the unsubstituted, un-run command back:

```{r}
cmd    # we get command back, not result of evaluating it
```

It may not seem like much, but it's a big deal R allows this: unevaluated R
commands can be directly manipulated by R itself.  We won't use that capability
here as all we care about at the moment is that the evaluation is on hold.  For
an example of what you can do with quoted commands see the [RPN in R post][28].

`list2env` creates a new environment which has for enclosure the global
environment as that is where we called it from.  This is possible because
environments are [akin to named lists](#env-desc).

```{r}
Lenv
ls.str(Lenv)
```
```{r}
parent.env(Lenv)   # parent.env == enclosure
```

`eval` provides a mechanism to resume evaluation with a different environment
chain for name lookups:

```{r}
eval(cmd, envir=Lenv)
```

This is what the environment chain looks like now right before substituting the
`w` name[^no-fun]:

<img
  src='/post/2020-02-13-on-nse_files/images/flip-1/img-015.png'
  alt='Adding an environment to the environment chain with eval.'
/>

By changing the environment chain we made the evaluation "Non-Standard".


Running `eval` without changing the starting environment produces the same
result as if we had typed the command at the prompt:

```{r}
eval(cmd) # envir defaults to parent.frame (global here)
```

Now look at what happens if we make a new mask that contains a `rev` symbol as
well:

```{r}
L2 <- list(rev=toupper)
L2env <- list2env(L2, parent=Lenv)
eval(cmd, envir=L2env)
```

We can change the meaning of both functions and values by modifying the
environment chain.  Notice how we set the enclosure to `L2env` to be `Lenv` with
the `parent` parameter to `list2env`[^par-vs-enc].  We could also have directly
added a `rev` mapping to `Lenv`.

Manipulating the environment chain is not the only way to perform NSE.  Anything
that changes the meaning of a command after it is issued relative to what would
have happened in standard evaluation is NSE.

# In Functions

Compare:

```{r}
with(L, rev(w))
```

To our hack-at-the-prompt version:

```{r}
cmd  <- quote(rev(w))
Lenv <- list2env(L)
eval(cmd, envir=Lenv)
```

It would be nice to implement `with` ourselves, if we try to use `quote` inside
a function to get what someone types in as the argument to that function we are
disappointed:

```{r}
with2 <- function(dat, cmd) {
  quote(cmd)                 # capture command
  # rest of function will go here later
}
with2(L, rev(w))
```

What we want to quote is the command supplied argument `cmd`, not the name
`cmd`.  Thankfully R in its infinite flexibility provides a mechanism for doing
this with `substitute`:

```{r}
with2 <- function(dat, cmd) {
  substitute(cmd)
  # rest of function will go here later
}
with2(L, rev(w))
```

When called within a function on a function parameter, `substitute` acts like
`quote` except it substitutes the unevaluated command passed as the actual
parameter.  This allows us to implement `with`:

```{r}
with2 <- function(dat, cmd) {
  cmd2 <- substitute(cmd)
  denv <- list2env(dat, parent=parent.frame())
  eval(cmd2, envir=denv)
}
with2(L, rev(w))
```

We can do a bit better because `eval` supports adding a list-like element to the
environment chain out of the box:

```{r}
with2 <- function(L, cmd) {
  cmd2 <- substitute(cmd)
  eval(cmd2, L, enclos=parent.frame())
}
with2(L, rev(w))
```

What's the `parent.frame()` business?  And why do we pass it as the `enclos`
argument for `eval`, but as the argument `parent` for `list2env`?

# Environmental Dichotomy

`substitute` allows us to implement functions that perform NSE on their
arguments.  This is a powerful feature, but with it comes a new class of
potential errors.  Notice in our `with2` implementation how we call `eval`:

```{r eval=FALSE}
eval(cmd2, L, enclos=parent.frame())
```

The key part is that we explicitly specify the enclosure to be `parent.frame()`.
We must do this to ensure the correct environment chain is used to resolve the
names in `cmd2`, i.e. `rev(w)`.  What is `parent.frame()`?  It is the
environment that the function currently under evaluation (`with2` here) was
invoked from.  We will call this environment the **calling** environment.

To understand why we must call `eval` with the enclosure set to the **calling**
environment, consider what happens when we don't do it:

```{r}
with2_bad <- function(L, cmd) {
  cmd2 <- substitute(cmd)
  eval(cmd2, L)
}
with2_bad(L, rev(w))
```

No problem right?  Except look at what happens with a pathological input:

```{r}
cmd2 <- c("pathological", "I", "am")
with2_bad(L, rev(cmd2))
```

Wow, what the heck is that?  It is the result of:

```{r}
rev(quote(rev(cmd2)))
```

The key thing to realize is that we had a name clash.  The `cmd2` symbol
associated in `with2_bad`'s **evaluation** environment masks the `cmd2` in the
**calling** environment.  We can avoid the clash by ensuring the current
**evaluation** environment is not involved in the call to `eval`.  `with2` does
this by setting the `enclosure` for `eval` to the **calling** environment so it
works as expected:


```{r}
cmd2 <- c("pathological", "I", "am")
with2(L, rev(cmd2))
```

No, you're not pathological, not anymore.

This is a contrived example as it requires the function doing NSE to have names
that mask those used in the captured call, but there are other ways things go
wrong.  If our function were called from within another function, then the names


```{r}
friendly_fun <- function(L) {
  z <- c('hello', 'friend', '!')
  with2_bad(L, paste(c(z, w), collapse=' '))
}
friendly_fun(L)
```

What happened?  Instead of using the `z` in `fun2`'s evaluation environment,
which in this case is `with2_bad`'s **calling** environment, we used the `z` in
the global environment.  Why?  Because the `with2_bad`'s **function**
environment, and hence the enclosure of it's **evaluation** environments, is the
global environment.  Again, this is resolved by explicitly setting the
evaluation enclosure to the **calling** frame with `parent.frame` as `with2`
does:

```{r}
friendly_fun <- function(L) {
  z <- c('hello', 'friend', '!')
  with2(L, paste(c(z, w), collapse=' '))
}
friendly_fun(L)
```



# Conclusions

<!-- this needs to become a shortcode -->
<!-- this is populated by JS in feedback.html partial -->
<p id='feedback-cont'></p>

# Appendix

## References

* [Survey of Macros in R][22]
* [R NSE Reference][27]
* [Tips on NSE in R][29] by Kun Ren
* [Original R Paper][30]


## Acknowledgments

Sumner.

* png

## Session Info

<!--
```{r child='../../static/script/_lib/zoom-img/zoom-img.Rmd', results='asis', cache=FALSE}
```
-->
```{r child='../../static/script/_lib/flipbook/flipbook.Rmd', results='asis', cache=FALSE}
```
<script type='text/javascript'>
const imgDir = '/post/2020-02-13-on-nse_files/images/flip-1/';
const fps = 1;
new BgFlipBook({
  targetId: 'flipbook1', imgDir: imgDir, imgStart: 1, imgEnd: 6,
  imgPad: "000", fps: fps, loop: true
})
new BgFlipBook({
  targetId: 'flipbook2', imgDir: imgDir, imgStart: 7, imgEnd: 13,
  imgPad: "000", fps: .3, loop: true, loopDelay: 3000
})
</script>

[20]: https://cran.r-project.org/doc/manuals/R-lang.html#Argument-evaluation
[21]: https://stat.ethz.ch/R-manual/R-devel/library/compiler/html/compile.html
[23]: https://github.com/WinVector/wrapr/blob/master/extras/MacrosInR.md
[24]: https://cran.r-project.org/doc/manuals/R-lang.html#Environment-objects
[25]: https://en.wikipedia.org/wiki/Hash_table
[26]: http://blog.obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/
[27]: http://developer.r-project.org/nonstandard-eval.pdf
[28]: /2019/01/11/reverse-polish-notation-parsing-in-r/
[29]: https://renkun.me/2014/12/03/tips-on-non-standard-evaluation-in-r/
[30]: https://www.stat.auckland.ac.nz/~ihaka/downloads/R-paper.pdf
[82]: /2019/02/18/an-unofficial-reference-for-internal-inspect/

[^earth-shattering]: Under no circumstances
[^more-complicated]: The actual meaning changes is more complicated, but we'll
  discuss that in the body of this post.
[^simple-model]: <span id='simple-model'>Items we gloss over include but are not
  limited to:<ul>
  <li>Function parameters are [evaluated lazily][20] so they are only fetched
  when they are referenced within a function body.
  <li>The [byte-compiler][21] affects the nature of non-evaluated code
  prefetching objects names point to and performing other optimizations.
  <li>Names representing called functions are only resolved against names that
  are associated with functions.
  <li>Lookups from the global environment down are usually done against a
  "global" hash table that replicates the semantics of the environment chain,
  but isn't actually a chain.
  <li>The base environment has an enclosure, although it is the empty
  environment which itself does not have an enclosure.
  <li>And more.</ul></span>
[^mostly-names]: In R "names" are not restricted to words in the typical sense.
  Symbols like `*`, `+`, and even `(` in some circumstances are also called
  "names".  "names" are also called "symbols" and the terms are often used
  interchangeably in the documentation.
[^parens]: The parentheses in `rev(x)` are not considered "names".  They are
  syntax tokens that are used to parse the command.  Opening parentheses that
  are not part of the syntax of a function call are names, as in `(1 + 2) * 3`.
[^run-recursive]: Where by "run the function" means retrieving the body of the
  function, and repeating the fetching we just went through, until eventually we
  start hitting statically compiled functions invoked via `.Primitive`,
  `.Internal`, and similar, when the actual computation occurs.  All the
  [aforementioned caveats](#simple-model) still apply, in particular that names
  are not actually substituted until they are used in a function body.
[^weapons-grade]: In reality the names are not substituted in place as we show
  here.  R will hold the function and a list of the arguments encapsulated as
  promises which it can then use to evaluate the body of the function.  Because
  the arguments are kept as promises they are not actually substituted until
  they are used in the body of the function, or in those of subsequent functions
  that they are forward to, or not all if they are not used.  However, in most
  cases were the argument is used and evaluating it does not cause side-effects,
  the observed behavior is as if the names had been substituted in place, or at
  least in place in a copy of the list.
[^not-object]: What's actually returned is a pointer to the location in memory
  the object is located at.  Since in R memory addresses are not directly
  visible, we'll pretend the actual objects instead of just pointers to them are
  returned.
[^fun-env-term]: <span id=fun-env-term>The correct term for what we call the
  "function enclosure" is "environment to use as the enclosure for the function
  evaluation environments".  So "function enclosure" is not strictly correct,
  but neither is "function environment", and "function enclosure" is much closer
  semantically to the correct term.</span>
[^env-vs-chain]: In some contexts the term "environment" is taken to mean the
  entire environment chain.  In fact, the term "environment chain" is not a term
  used by the R documentation.
[^fun-create]: That is the default behavior, but is possible to change what the
  enclosing environment for any given function's evaluation environments will
  be with `environment(fun) <- `.  See also the discussion of [function
  evaluation environment terminology](#fun-env-term).
[^search-path]: Packages in R have multiple environments associated with them.
  We're hand-waving away distinctions between them, but they exist and are
  important.  Saruj Gupta's ["How R Searches and Finds Stuff"][29] is a
  must-read if you want to understand all the details.
[^name-vs-pkg]: Strictly speaking it is the base namespace environment, not the
  base package environment.
[^closures]: Functions created with `function` in R are called "closures"
  because they have an enclosure.  There are other types of functions without
  such an environment.  These are called "builtin" or "special" functions.  They
  do not reference environments as they link directly to statically compiled
  code and do not need to look up names.
[^use-method]: It turns out `UseMethod` invokes one of those statically compiled
  routines.  It also so happens that routine does some frightful
  uber-non-standard-evaluation, but we're just going to gloss over that
  business.  If you're really interested see `?UseMethod`.
[^fun-body]: The function "body" is the set of commands that follow the
  declaration.  In `function(...) {<function-body>}` the body is the set of
  commands that would replace the `<function-body>` placeholder.
[^value-copy]: R only copies objects when necessary to maintain the
  "pass-by-value" illusion.  See ["The Secret Lives Of R Objects"][31] for more
  details.
[^no-fun]: Environments can have multiple children [as we saw
  previously](#rev-chain).  While not shown here `fun`'s environment from
  earlier is still linked to the global environment.
[^par-vs-enc]: Unfortunately the terminology around the hierarchical
  relationship of environments in R is muddled.  In early days the term "parent"
  was used for enclosures, which is why `parent.env` returns the enclosure of an
  environment.  However, there is also the `parent.frame`, which is the
  evaluation environment of the command that that triggered the current
  evaluation.  The `parent.frame` is known as the "calling environment".



