---
title: Hacky Stereography
author: ~
date: '2018-10-26'
slug: hacky-stereography
categories: []
tags: []
---
```
knitr::opts_chunk$set(
  eval='FALSE', echo='FALSE', comment = ""
)
```

# Cool, but Not Eye Popping

As we saw in our previous [blog post](/2018/10/23/do-not-shade-r/), you can do
some pretty cool things with `rayshader`:

```{r}
plot(as.raster((volcano - min(volcano))/diff(range(volcano))))
```

It is so beautiful it looks _almost_ 3D.  So why not actually make it 3D?  We
have the elevation data after all.  Much of what we are going to do here can be
done with `rgl`, but what's the fun in that?  Besides, there are few things as
fun as procrastinating by learning about a fundamental component of computer graphics.  Okay, maybe I don't get out much.

So come along for a ride through 3D projections, perspective adjustments,
rasterization, and image processing, all in base R.

# Step 0: Volcano!

Sure, you've seen volcano a million times:

```{r}
plot(as.raster((t(volcano) - min(volcano))/diff(range(volcano))))
plot(as.raster((volcano - min(volcano))/diff(range(volcano))))
image((volcano - min(volcano))/diff(range(volcano)))
v2 <- volcano[60:nrow(volcano),]
plot(as.raster((v2 - min(v2))/diff(range(v2))))
which(v2==max(v2), arr.ind=TRUE)
plot.new()
points(
  x=c(row(volcano) - 1)/(nrow(volcano) - 1),
  y=c(col(volcano) - 1)/(ncol(volcano) - 1),
  col=gray((volcano - min(volcano))/diff(range(volcano))),
  pch=15
)
```

Let's add some shading:

```{r}
library(shadow)
sh <- ray_shade2(volcano, seq(-90, 90, length=25), sunangle=180)
par(mai=numeric(4L))
plot(as.raster(t(sh)))
```

# Step 1: 3D Projection

While volcano looks pretty cool from above, we want to provide a more
interesting view.  To do this we can use [3D rotation matrices][1].  `shadow`
implements the `rot_*` functions, which are thin wrappers that generate the
rotation matrices described in the wikipedia article:

```{r}
rot_z
round(rot_z(65), 3)
```

By convention 


In order to
use the rotation matrix we need our data in long format.  This can be done
easily by taking advantage of the `row` and `col` functions that return
respectively the row and column indices of each element in the vector underlying
the matrix:

```{r}
mx.example <- matrix(numeric(4), nrow=2, ncol=2)
row(mx.example)
col(mx.example)
```

So now we can make a long version of `volcano`:

```{r}
v2 <- cbind(x=c(row(volcano)), y=c(col(volcano)), z=c(volcano))
str(v2)
str(volcano)
```

We will use `rot_x` and `rot_z` form the 

The `rot_x` and `rot_z` functions used here produce the matrices as described in
the
wikipedia article:

```{r}
rot_x(-20)
rot_z(65)
rot <- rot_x(-20) %*% rot_z(65)
```

We're going to tilt the map to the left and to the right by two degrees.  I just
picked an angle that seemed reasonable, and given that a true human stereoscopic
view of mountains is physically impossible I'm not going to worry too much about
doing this correctly.

Additionally, our tilt is going to be lazy.  As in,
really-wrong-but-not-wrong-enough-to-ruin-everything lazy.
We are only going to shift heights along the x-axis in proportion to the
heights, instead of rotating the entire plane.  We do this with the
`shift_shadow` function:

```{r}
mx2 <- volcano
els <- seq(-90, 90, length=25)
sun <- 180
sh2 <- ray_shade2(mx2, els, sun)
sh2 <- sh2 * .9 + .1
rot <- rot_x(-20) %*% rot_z(65)

proj <- project_elev(
  mx2, sh2, rot, parallax=0, dist=1e6, resolution=c(600,600)
)
left <- proj[[1]]
empty.rows <- which(empty_rows(left))
empty.cols <- which(empty_cols(left))
left <- left[-empty.rows, -empty.cols, ]

left.r <- left[,,1]
left.r[left.r < 0] <- 0

# image(left.r)
plot(as.raster(left.r))
```

# Stereoscopy in R

After figuring out how to implement ray-shading with base R I was left wanting a
little more.  The shading is so effective at conveying the impression of depth,
but I r

## stereo angle

```{r rgl, eval=FALSE}
empty_rows <- function(arr) (rowSums(arr) == 3 * ncol(arr))
empty_cols <- function(arr) (rowSums(colSums(arr)) == 3 * nrow(arr))

angle <- 4

library(rgl)
rot.rgl <- 
  rotationMatrix(-20/180*pi, 1, 0, 0) %*% rotationMatrix(65/180*pi, 0, 0, 1)

mfrow3d(1, 2)
width <- height <- 600
# par3d(windowRect=c(0,0,width*2,height))
par3d(windowRect=c(0,0,width,height))
# par3d(viewport=c(0,0,width,height))
# mx <- volcano[,rev(seq_len(ncol(volcano)))]
# sh2 <- sh[,rev(seq_len(ncol(sh)))]

persp3d(
  x=seq_len(nrow(volcano)), y=seq_len(ncol(volcano)), 
  z=c(volcano), color=gray(sh), lit=FALSE, aspect="iso"
)
view3d(0,0,fov=0)
rgl.viewpoint(userMatrix=rot.rgl, fov=0)

# persp3d(seq_len(nrow(mx)), seq_len(ncol(mx)), c(mx),
#   color=rgb(c(sh2), c(sh2), c(sh2)), lit=FALSE,
#   xlab="X", ylab="Y", zlab="Z", box=FALSE, axes=TRUE
# )
# persp3d(mx,
#   color=rgb(c(sh2), c(sh2), c(sh2)), lit=FALSE,
#   xlab="X", ylab="Y", zlab="Z", box=FALSE, axes=TRUE
# )
view3d(0,0, )
rgl.viewpoint(userMatrix=rot, fov=0)

# next3d()
# persp3d(seq_len(nrow(mx)), seq_len(ncol(mx)), c(mx),
#   color=rgb(c(sh), c(sh), c(sh)), lit=FALSE,
#   xlab="X", ylab="Y", zlab="Z", box=FALSE, axes=TRUE
# )
# view3d(0,0)


image(sh2)


M <- identityMatrix()

play3d(
  par3dinterp(time = (0:2)*0.75, userMatrix=list(M,
                                     rotate3d(M, pi/2, 1, 0, 0),
                                     rotate3d(M, pi/2, 0, 1, 0) ) ) )

aspect3d(1, 1, 1)
rgl.viewpoint(userMatrix=t(XR) %*% t(ZRl), type='modelviewpoint', zoom=.7)
snapshot3d('persp-left.png')

clear3d()
persp_elev(mx, sh.s)
rgl.viewpoint(userMatrix=t(XR) %*% t(ZRr), type='modelviewpoint')
snapshot3d('persp-right.png')

# stitch images together

left <- png::readPNG('persp-left.png')
right <- png::readPNG('persp-right.png')
stopifnot(identical(dim(left), dim(right)))

# remove rows and columns that are blank in both images

empty.rows <- which(empty_rows(left) & empty_rows(right))
empty.cols <- which(empty_cols(left) & empty_cols(right))
left <- left[-empty.rows, -empty.cols, ]
right <- right[-empty.rows, -empty.cols, ]

# figure out how close we can get the left and right images before we
# start overlapping non-white pixels

no.overlap <- rowSums(left[, rev(seq_len(ncol(left))),], dims=2) == 3 |
  rowSums(right, dims=2) == 3
no.over.rle <- rle(colSums(no.overlap) == nrow(no.overlap))
overlap.size <- if(isTRUE(no.over.rle[['values']][1]))
  no.over.rle[['lengths']][1] else 0L

# combine and write png

combined <- array(0, dim=dim(left) * c(1,2,1) - c(0, overlap.size, 0))
combined[,seq_len(ncol(left)),] <- left
combined[,tail(seq_len(ncol(combined)), ncol(right)),] <-
  combined[,tail(seq_len(ncol(combined)), ncol(right)),] + right
png::writePNG(combined, 'persp.png')
```

[1]: https://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions
