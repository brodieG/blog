---
title: Hacky Stereography
author: ~
date: '2018-10-26'
slug: hacky-stereography
categories: []
tags: []
---
```
knitr::opts_chunk$set(
  eval='FALSE', echo='FALSE', comment = ""
)
```

# Cool, but Not Eye Popping

As we saw in our previous [blog post](/2018/10/23/do-not-shade-r/), you can do
some pretty cool things with `rayshader`:

```{r}
plot(as.raster((volcano - min(volcano))/diff(range(volcano))))
```

It is so beautiful it looks _almost_ 3D.  So why not actually make it 3D?  We
have the elevation data after all.  Much of what we are going to do here can be
done with `rgl`, but what's the fun in that?  Besides, there are few things as
fun as procrastinating by learning about a fundamental component of computer graphics.  Okay, maybe I don't get out much.

So come along for a ride through 3D projections, perspective adjustments,
rasterization, and image processing, all in base R.

# Step 0: Volcano!

Sure, you've seen volcano a million times:

```{r}
plot(as.raster((t(volcano) - min(volcano))/diff(range(volcano))))
plot(as.raster((volcano - min(volcano))/diff(range(volcano))))
image((volcano - min(volcano))/diff(range(volcano)))
v2 <- volcano[60:nrow(volcano),]
plot(as.raster((v2 - min(v2))/diff(range(v2))))
which(v2==max(v2), arr.ind=TRUE)
plot.new()
points(
  x=c(row(volcano) - 1)/(nrow(volcano) - 1),
  y=c(col(volcano) - 1)/(ncol(volcano) - 1),
  col=gray((volcano - min(volcano))/diff(range(volcano))),
  pch=15
)
```

Let's add some shading:

```{r}
library(shadow)
sh <- ray_shade2(volcano, seq(-90, 90, length=25), sunangle=180)
par(mai=numeric(4L))
plot(as.raster(t(sh)))
```

# Step 1: 3D Projection

While volcano looks pretty cool from above, we want to provide a more
interesting view.  To do this we can use [3D rotation matrices][1].  In order to
be able to use the rotation matrix we need to restructure our data into three
column matrices with x, y, and z values, instead of a matrix of z values as we
currently have.

```{r}
v2 <- cbind(x=c(row(volcano)), y=c(col(volcano)), z=c(volcano))
str(v2)
str(volcano)
```


The `rot_x`
and `rot_z` functions used here produce the matrices as described in the
wikipedia article:

```{r}
rot_x(-20)
rot_z(65)
rot <- rot_x(-20) %*% rot_z(65)
```

We're going to tilt the map to the left and to the right by two degrees.  I just
picked an angle that seemed reasonable, and given that a true human stereoscopic
view of mountains is physically impossible I'm not going to worry too much about
doing this correctly.

Additionally, our tilt is going to be lazy.  As in,
really-wrong-but-not-wrong-enough-to-ruin-everything lazy.
We are only going to shift heights along the x-axis in proportion to the
heights, instead of rotating the entire plane.  We do this with the
`shift_shadow` function:

# Stereoscopy in R

After figuring out how to implement ray-shading with base R I was left wanting a
little more.  The shading is so effective at conveying the impression of depth,
but I r

## stereo angle

```{r rgl, eval=FALSE}
empty_rows <- function(arr) (rowSums(arr) == 3 * ncol(arr))
empty_cols <- function(arr) (rowSums(colSums(arr)) == 3 * nrow(arr))

angle <- 4

library(rgl)
rot <- rotationMatrix(-20/180*pi, 1, 0, 0) %*% rotationMatrix(65/180*pi, 0, 0, 1)

mfrow3d(1, 2)
width <- height <- 600
# par3d(windowRect=c(0,0,width*2,height))
par3d(windowRect=c(0,0,width,height))
# par3d(viewport=c(0,0,width,height))
# mx <- volcano[,rev(seq_len(ncol(volcano)))]
# sh2 <- sh[,rev(seq_len(ncol(sh)))]

v2 <- (volcano - min(volcano)) / diff(range(volcano))
persp3d(v2, color=gray(sh), lit=FALSE)

# persp3d(seq_len(nrow(mx)), seq_len(ncol(mx)), c(mx),
#   color=rgb(c(sh2), c(sh2), c(sh2)), lit=FALSE,
#   xlab="X", ylab="Y", zlab="Z", box=FALSE, axes=TRUE
# )
# persp3d(mx,
#   color=rgb(c(sh2), c(sh2), c(sh2)), lit=FALSE,
#   xlab="X", ylab="Y", zlab="Z", box=FALSE, axes=TRUE
# )
view3d(0,0)
rgl.viewpoint(userMatrix=rot)

# next3d()
# persp3d(seq_len(nrow(mx)), seq_len(ncol(mx)), c(mx),
#   color=rgb(c(sh), c(sh), c(sh)), lit=FALSE,
#   xlab="X", ylab="Y", zlab="Z", box=FALSE, axes=TRUE
# )
# view3d(0,0)


image(sh2)


M <- identityMatrix()

play3d(
  par3dinterp(time = (0:2)*0.75, userMatrix=list(M,
                                     rotate3d(M, pi/2, 1, 0, 0),
                                     rotate3d(M, pi/2, 0, 1, 0) ) ) )

aspect3d(1, 1, 1)
rgl.viewpoint(userMatrix=t(XR) %*% t(ZRl), type='modelviewpoint', zoom=.7)
snapshot3d('persp-left.png')

clear3d()
persp_elev(mx, sh.s)
rgl.viewpoint(userMatrix=t(XR) %*% t(ZRr), type='modelviewpoint')
snapshot3d('persp-right.png')

# stitch images together

left <- png::readPNG('persp-left.png')
right <- png::readPNG('persp-right.png')
stopifnot(identical(dim(left), dim(right)))

# remove rows and columns that are blank in both images

empty.rows <- which(empty_rows(left) & empty_rows(right))
empty.cols <- which(empty_cols(left) & empty_cols(right))
left <- left[-empty.rows, -empty.cols, ]
right <- right[-empty.rows, -empty.cols, ]

# figure out how close we can get the left and right images before we
# start overlapping non-white pixels

no.overlap <- rowSums(left[, rev(seq_len(ncol(left))),], dims=2) == 3 |
  rowSums(right, dims=2) == 3
no.over.rle <- rle(colSums(no.overlap) == nrow(no.overlap))
overlap.size <- if(isTRUE(no.over.rle[['values']][1]))
  no.over.rle[['lengths']][1] else 0L

# combine and write png

combined <- array(0, dim=dim(left) * c(1,2,1) - c(0, overlap.size, 0))
combined[,seq_len(ncol(left)),] <- left
combined[,tail(seq_len(ncol(combined)), ncol(right)),] <-
  combined[,tail(seq_len(ncol(combined)), ncol(right)),] + right
png::writePNG(combined, 'persp.png')
```

[1]: https://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions
