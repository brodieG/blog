---
title: Hacky Stereography
author: ~
date: '2018-10-26'
slug: hacky-stereography
categories: []
tags: []
---
```
knitr::opts_chunk$set(
  eval='FALSE', echo='FALSE', comment = ""
)
```

# Cool, but Not Eye Popping

As we saw in our previous [blog post](/2018/10/23/do-not-shade-r/), you can do
some pretty cool things with `rayshader`:

```{r}
plot(as.raster((volcano - min(volcano))/diff(range(volcano))))
```

It is so beautiful it looks _almost_ 3D.  So why not actually make it 3D?  We
have the elevation data after all.  Much of what we are going to do here can be
done with `rgl`, but what's the fun in that?  Besides, there are few things as
fun as procrastinating by learning about a fundamental component of computer
graphics.  Okay, maybe I don't get out much.

So come along for a ride through 3D projections, perspective adjustments,
rasterization, and image processing, all in base R.

# Step 0: Volcano!

Sure, you've seen volcano a million times:

```{r}
scale <- function(x, range=1)
  ((x - min(x, na.rm=TRUE)) / diff(range(x, na.rm=TRUE))) *
    range + (1 - range) / 2
flip <- function(x) t(x)[rev(seq_len(ncol(x))),]

# plot(as.raster(flip(scale(volcano))))

par(mai=numeric(4L), xaxt='n', yaxt='n', xaxs='i', yaxs='i')
plot.new()
plot.window(c(0,1), c(0,1), asp=ncol(volcano)/nrow(volcano))
points(
  x=scale(row(volcano)), y=scale(col(volcano)),
  col=gray(scale(volcano)), pch=15, cex=.5
)
```

Let's add some shading:

```{r}
library(shadow)
sh <- ray_shade2(volcano, seq(-90, 90, length=25), sunangle=180)
par(mai=numeric(4L), xaxt='n', yaxt='n', xaxs='i', yaxs='i')
plot.new()
points(
  x=scale(row(volcano)), y=scale(col(volcano)),
  col=gray(sh), pch=15, cex=0.5
)
```

# Step 1: 3D Projection

While volcano looks pretty cool from above, we want to provide a more
interesting view.  To do this we can use [3D rotation matrices][1].  `shadow`
implements the `rot_*` functions, which are thin wrappers that generate the
rotation matrices described in the wikipedia article:

```{r}
rot_z
round(rot_z(65), 3)
```

By our convention the Z-axis is always pointed directly at the user, even after
rotations are applied.  In other words, it is the model that rotates, not the
viewer.

In order to use the rotation matrix we need our data in long format.  This can
be done easily by taking advantage of the `row` and `col` functions that return
respectively the row and column indices of each element in the vector underlying
the matrix:

```{r}
mx.example <- matrix((0:3)*10, nrow=2, ncol=2)
row(mx.example)
col(mx.example)
cbind(c(row(mx.example)), c(col(mx.example)), c(mx.example))
```

So now we can make a long version of `volcano`:

```{r}
volc.l <- rbind(x=c(row(volcano)), y=c(col(volcano)), z=c(volcano))
str(volc.l)
str(volcano)
```

Which we can rotate with our rotation matrices:

```{r}
rot <- rot_x(-20) %*% rot_z(65)
volc.lr <- rot %*% volc.l
```

From this point forward we will be using list data structures instead of
matrices as we have found them [to be more efficient][2] for the problem we're
dealing with.

```{r, echo=FALSE}
asp <- diff(range(volc.lr[2,])) / diff(range(volc.lr[1,]))
plot.window(0:1, 0:1, asp=asp)
```
```{r}
## construct list data structure, adding texture/shadow info
vl <- lapply(seq_len(nrow(volc.lr)), function(x) volc.lr[x,])
vl <- c(vl, list(sh))              # add texture info
names(vl) <- c('x', 'y', 'z', 't') # 't' for texture

## Plot!, but order by Z value first
zord <- order(vl[[3]])
vlo <- lapply(c(1:2,4), function(x) scale(vl[[x]][zord]))
plot.new()
points(x=vlo[[1]], y=vlo[[2]], col=gray(vlo[[3]]), pch=15, cex=0.5)
```

The good news is now we have an awesome looking 3D rendition of our volcano...
in the process of disintegration from a particularly unpleasant eruption.

# Step 2: Meshes

Okay, so we can't just use our elevation data as point coordinates.  One
possibility is to turn our point "cloud" into a mesh.  Well, turning an
arbitrary point cloud into a mesh is one of those problems that seems very easy
but in reality is anything but.  Worse, the typical implementations involve some
kind of sequential process that is repeated many times until the mesh is
complete.  These types of algorithms cannot be implemented efficiently in R,
though there are R packages that implement them in compiled code.

Fortunately for us and our base-R only challenge, our point cloud is not
arbitrary.  The source data contains the information required to build the mesh:
the original x-y grid.  We can generate a tile mesh by sampling our data four
times, once for each of the four vertices for each tile.  This is what it looks
like with an illustrative 4 x 4 grid:

```{r echo=FALSE, fig.width=5.5, fig.height=1.5}
p.seq <- seq(.05, .95, length.out=4)
points <- expand.grid(x=p.seq, y=p.seq)
len <- length(p.seq)
vert.box <- data.frame(
  x=c(.025, p.seq[3] + .025, p.seq[3] + .025, .025),
  y=c(-.025 + p.seq[2], -.025 + p.seq[2], .025 + p.seq[4], .025 + p.seq[4])
)
seq.diff <- diff(p.seq[1:2])
# dev.new(width=5, height=1.5)
old.par <- par(mfrow=c(1,4), mar=c(.5, .25, 2, .25))
x.off <- c(0, 1, 1, 0)
y.off <- c(1, 1, 0, 0)
for(i in seq_along(p.seq)) {
  plot.new()
  plot.window(0:1, 0:1, asp=1)
  title(sprintf('Vertex %d', i))
  polygon(c(0, 1, 1, 0), c(0, 0, 1, 1), col='#EEEEEE', border=NA)
  points(points, pch=15, cex=0.5)
  polygon(
    x=vert.box[['x']] + seq.diff * x.off[i],
    y=vert.box[['y']] - seq.diff * y.off[i]
  )
}
par(old.par)
```

We alternate dropping the first/last row/column.  Because our rotated volcano
data is already in long format this requires a little extra work:

```{r}
nr <- dim(volcano)[1]
nc <- dim(volcano)[2]
idx.raw <- matrix(seq_along(volcano), nr, nc)
idx.tile <- list(
  idx.raw[-nr, -nc, drop=TRUE],
  idx.raw[-nr,  -1, drop=TRUE],
  idx.raw[ -1,  -1, drop=TRUE],
  idx.raw[ -1, -nc, drop=TRUE]
)
```

For each of our vectors from our rotated volcano, we will use `idx.tile` to pull
out the vertex data for the tiles.  This does unfortunately mean we have several
duplicative copies of the same data.

```{r}
mesh.tile <- matrix(
  Map(
    function(x, y) vl[[y]][idx.tile[[x]]],
    rep(seq_along(idx.tile), length(vl)),
    rep(seq_along(vl), each=length(idx.tile))
  ),
  nrow=length(idx.tile),
  ncol=length(vl),
  dimnames=list(sprintf('v%d', seq_along(idx.tile)), names(vl))
)
```

Tada! A mesh:

```{r}
x <- do.call(rbind, c(mesh.tile[,'x'], list(NA)))
y <- do.call(rbind, c(mesh.tile[,'y'], list(NA)))
# dev.new(width=8, height=6)
plot.new()
polygon(scale(x), scale(y))
```

But a tile mesh is not ideal.  Among other things, there is no guarantee the
tiles are flat.  Triangles on the other hand are guaranteed to be flat, and
additionally benefit from simple shading algorithms.  So we will turn our tiles
into triangles as we do here by turning the black tile into the blue and green
triangles:

```{r}
par(mai=numeric(4))
plot.new()
polygon(c(0, 1, 1, 0), c(0, 0, 1, 1), col='#EEEEEE', border=NA)
polygon(scale(c(0, 1, 1, 0), .9), scale(c(0, 0, 1, 1), .9))
text(
  scale(c(0, 1, 1, 0), .95), scale(c(0, 0, 1, 1), .95),
  labels=sprintf('v%d', 1:4)
)
polygon(
  scale(c(0, 1, 1), .8) + .0125, scale(c(0, 0, 1), .8) - .0125,
  border='#0000FF'
)
text(
  scale(c(0, 1, 1), .7) + .03, scale(c(0, 0, 1), .7) - .03,
  labels=sprintf('v%d', 1:3), col='#0000FF'
)
polygon(
  scale(c(1, 0, 0), .8) - .0125, scale(c(1, 1, 0), .8) + .0125,
  border='#00FF00'
)
text(
  scale(c(1, 0, 0), .7) - .03, scale(c(1, 1, 0), .7) + .03,
  labels=sprintf('v%d', c(3,4,1)), col='#00FF00'
)
```

Our data is nicely structured that the translation from tile to triangle mesh is
trivial:

```{r}
tri.blue <- 1:3
tri.green <- c(3,4,1)
mesh.tri <- Map('c', mesh.tile[tri.blue,], mesh.tile[tri.green,])
dim(mesh.tri) <- c(3, 4)
dimnames(mesh.tri) <- list(head(rownames(mesh.tile), -1), colnames(mesh.tile))
mesh.tri
```


```{r eval=FALSE}
width <- height <- 600
# par3d(windowRect=c(0,0,width*2,height))
par3d(windowRect=c(0,0,width,height))
clear3d()
polygon3d(x=c(0, 1, 2, 1, 0), y=c(0, 2, 0, .2, 0), z=numeric(5))
view3d(0,0,fov=60)
```

The `rot_x` and `rot_z` functions used here produce the matrices as described in
the
wikipedia article:


We're going to tilt the map to the left and to the right by two degrees.  I just
picked an angle that seemed reasonable, and given that a true human stereoscopic
view of mountains is physically impossible I'm not going to worry too much about
doing this correctly.

Additionally, our tilt is going to be lazy.  As in,
really-wrong-but-not-wrong-enough-to-ruin-everything lazy.
We are only going to shift heights along the x-axis in proportion to the
heights, instead of rotating the entire plane.  We do this with the
`shift_shadow` function:

```{r eval=FALSE}
mx2 <- volcano
els <- seq(-90, 90, length=25)
sun <- 180
sh2 <- ray_shade2(mx2, els, sun)
sh2 <- sh2 * .9 + .1
rot <- rot_x(-20) %*% rot_z(65)

proj <- project_elev(
  mx2, sh2, rot, parallax=0, dist=1e6, resolution=c(600,600)
)
left <- proj[[1]]
empty.rows <- which(empty_rows(left))
empty.cols <- which(empty_cols(left))
left <- left[-empty.rows, -empty.cols, ]

left.r <- left[,,1]
left.r[left.r < 0] <- 0

# image(left.r)
plot(as.raster(left.r))
```

# Stereoscopy in R

After figuring out how to implement ray-shading with base R I was left wanting a
little more.  The shading is so effective at conveying the impression of depth,
but I r

## stereo angle

```{r rgl, eval=FALSE}
empty_rows <- function(arr) (rowSums(arr) == 3 * ncol(arr))
empty_cols <- function(arr) (rowSums(colSums(arr)) == 3 * nrow(arr))

angle <- 4

library(rgl)
rot.rgl <-
  rotationMatrix(-20/180*pi, 1, 0, 0) %*% rotationMatrix(65/180*pi, 0, 0, 1)

mfrow3d(1, 2)
width <- height <- 600
# par3d(windowRect=c(0,0,width*2,height))
par3d(windowRect=c(0,0,width,height))
# par3d(viewport=c(0,0,width,height))
# mx <- volcano[,rev(seq_len(ncol(volcano)))]
# sh2 <- sh[,rev(seq_len(ncol(sh)))]

persp3d(
  x=seq_len(nrow(volcano)), y=seq_len(ncol(volcano)),
  z=c(volcano), color=gray(sh), lit=FALSE, aspect="iso",
  box=FALSE, axes=FALSE, xlab="", ylab="", zlab=""
)
rgl.viewpoint(userMatrix=rot.rgl, fov=60)
view3d(0,0,fov=0)

# persp3d(seq_len(nrow(mx)), seq_len(ncol(mx)), c(mx),
#   color=rgb(c(sh2), c(sh2), c(sh2)), lit=FALSE,
#   xlab="X", ylab="Y", zlab="Z", box=FALSE, axes=TRUE
# )
# persp3d(mx,
#   color=rgb(c(sh2), c(sh2), c(sh2)), lit=FALSE,
#   xlab="X", ylab="Y", zlab="Z", box=FALSE, axes=TRUE
# )
view3d(0,0, )
rgl.viewpoint(userMatrix=rot, fov=0)

# next3d()
# persp3d(seq_len(nrow(mx)), seq_len(ncol(mx)), c(mx),
#   color=rgb(c(sh), c(sh), c(sh)), lit=FALSE,
#   xlab="X", ylab="Y", zlab="Z", box=FALSE, axes=TRUE
# )
# view3d(0,0)


image(sh2)


M <- identityMatrix()

play3d(
  par3dinterp(time = (0:2)*0.75, userMatrix=list(M,
                                     rotate3d(M, pi/2, 1, 0, 0),
                                     rotate3d(M, pi/2, 0, 1, 0) ) ) )

aspect3d(1, 1, 1)
rgl.viewpoint(userMatrix=t(XR) %*% t(ZRl), type='modelviewpoint', zoom=.7)
snapshot3d('persp-left.png')

clear3d()
persp_elev(mx, sh.s)
rgl.viewpoint(userMatrix=t(XR) %*% t(ZRr), type='modelviewpoint')
snapshot3d('persp-right.png')

# stitch images together

left <- png::readPNG('persp-left.png')
right <- png::readPNG('persp-right.png')
stopifnot(identical(dim(left), dim(right)))

# remove rows and columns that are blank in both images

empty.rows <- which(empty_rows(left) & empty_rows(right))
empty.cols <- which(empty_cols(left) & empty_cols(right))
left <- left[-empty.rows, -empty.cols, ]
right <- right[-empty.rows, -empty.cols, ]

# figure out how close we can get the left and right images before we
# start overlapping non-white pixels

no.overlap <- rowSums(left[, rev(seq_len(ncol(left))),], dims=2) == 3 |
  rowSums(right, dims=2) == 3
no.over.rle <- rle(colSums(no.overlap) == nrow(no.overlap))
overlap.size <- if(isTRUE(no.over.rle[['values']][1]))
  no.over.rle[['lengths']][1] else 0L

# combine and write png

combined <- array(0, dim=dim(left) * c(1,2,1) - c(0, overlap.size, 0))
combined[,seq_len(ncol(left)),] <- left
combined[,tail(seq_len(ncol(combined)), ncol(right)),] <-
  combined[,tail(seq_len(ncol(combined)), ncol(right)),] + right
png::writePNG(combined, 'persp.png')
```

[1]: https://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions
[2]: https://www.brodieg.com/2018/11/23/is-your-matrix-running-slow-try-lists/
