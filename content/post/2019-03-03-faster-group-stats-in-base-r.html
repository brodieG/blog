---
title: Faster Group Stats in Base R
author: ~
date: '2019-03-03'
slug: faster-group-stats-in-base-r
categories: []
tags: []
image: /front-img/default.png
imagerect: ~
imagemrgvt: 0%
imagemrghz: 0%
draft: true
weight: 1
contenttype: article
description: Front page summary
---



<div id="header-1" class="section level1">
<h1>Header 1</h1>
<!-- this needs to become a shortcode -->
<p><img
  id='front-img' src='/front-img/default.png'
  class='post-inset-image'
/></p>
<pre class="r"><code># Note: adapted to handle na.rm as per winvector, don&#39;t necessarily
# handle corner cases correctly (0, 1 length vectors, others?)

# Note: this stuff is only fast because order(, method=&quot;radix&quot;) is fast

sum_g2 &lt;- function(x, grp, na.rm=FALSE) {
  ord &lt;- order(grp)
  grp.ord &lt;- grp[ord]
  grp.rle &lt;- rle(grp.ord)
  grp.rle.c &lt;- cumsum(grp.rle[[&#39;lengths&#39;]])
  x.ord &lt;- x[ord]
  has.na &lt;- anyNA(x)

  if(has.na) {
    na.x &lt;- is.na(x)
    x.ord[na.x] &lt;- 0
  } else na.x &lt;- logical()

  x.grp.c &lt;- cumsum(x.ord)[grp.rle.c]
  x.grp.c[-1L] &lt;- x.grp.c[-1L] - x.grp.c[-length(x.grp.c)]

  if(!na.rm &amp;&amp; has.na)
    x.grp.c[match(grp.ord[na.x], grp.rle[[&#39;values&#39;]])] &lt;- NA

  structure(x.grp.c, groups=grp.rle[[&#39;values&#39;]])
}
sum_g3 &lt;- function(x, grp, na.rm=TRUE) {
  ord &lt;- order(grp)
  id.ord &lt;- id[ord]
  grp.ord &lt;- grp[ord]
  grp.rle &lt;- rle(grp.ord)
  max.grp &lt;- max(grp.rle[[&#39;lengths&#39;]])

  res &lt;- matrix(NA_real_, ncol=length(grp.rle[[&#39;lengths&#39;]]), nrow=max.grp)

  # each group that isn&#39;t as long as the longest group needs padding

  rle.len &lt;- grp.rle[[&#39;lengths&#39;]]
  grp.pad &lt;- max.grp - rle.len
  id.raw &lt;- rep(1L, length(x))
  id.raw[(cumsum(rle.len) + 1L)[-length(rle.len)]] &lt;-
    grp.pad[-length(rle.len)] + 1L
  id &lt;- cumsum(id.raw)

  res[id] &lt;- x[ord]
  structure(colSums(res, na.rm=na.rm), groups=grp.rle[[&#39;values&#39;]])
}

DT &lt;- copy(DT.raw)
system.time(res.ref &lt;- DT[, sum(x), keyby=grp][[&#39;V1&#39;]])
#   user  system elapsed
#  1.071   0.134   1.216
system.time(res &lt;- sum_g2(x, grp))
#   user  system elapsed
#  1.286   0.309   1.692
all.equal(res, res.ref, check.attributes=FALSE) # TRUE

system.time(res2 &lt;- sum_g2(x, grp))
system.time(res3 &lt;- sum_g3(x, grp))
system.time(res4 &lt;- rowsum(x, grp))

sum_winvector &lt;- function(DF) {
  odata &lt;- DF[order(DF$grp),,drop=FALSE]
  first_indices &lt;- mark_first_in_each_group(odata, &quot;grp&quot;)
  sum_g(odata[[&#39;x&#39;]], first_indices)
}</code></pre>
<pre><code>  user  system elapsed
 1.810   0.740   2.651</code></pre>
<p>Note on vector size<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
</div>
<div id="conclusions" class="section level1">
<h1>Conclusions</h1>
<!-- this needs to become a shortcode -->
<!-- this is populated by JS in feedback.html partial -->
<div id="feedback-cont">

</div>
</div>
<div id="appendix" class="section level1">
<h1>Appendix</h1>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Numeric vectors require 8 bytes per element plus some overhead for
the object meta data.<a href="#fnref1" class="footnote-back">â†©</a></p></li>
</ol>
</div>
