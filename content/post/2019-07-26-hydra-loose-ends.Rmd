---
title: "Hydra Chronicles Part V: Loose Ends"
author: ~
date: '2019-07-26'
slug: hydra-loose-ends
categories: [r]
tags: [group-stats,optim,hydra]
image:
  /post/2019-07-26-hydra-loose-ends_files/user-imgs/loose-ends-square.png
imagerect:
  /post/2019-07-26-hydra-loose-ends_files/user-imgs/loose-ends-rect.png
imagemrgvt: 0%
imagemrghz: 0%
weight: 1
contenttype: article
description: Front page summary
---

```{r echo=FALSE}
old.opt <- options(digits=3)
knitr::opts_chunk$set(comment = "", fig.align='center', error=TRUE)
suppressMessages(library(ggplot2))
suppressMessages(library(viridisLite))
suppressMessages(library(data.table))
setDTthreads(1)
```
```{r echo=FALSE, comment="", results='asis'}
old.hooks <- fansi::set_knit_hooks(knitr::knit_hooks)
options(fansi.term.cap=c('bright', '256', 'truecolor'))
```

# Almost Done!

<!-- this needs to become a shortcode -->
<img
  id='front-img' 
  src='/post/2019-07-26-hydra-loose-ends_files/user-imgs/loose-ends-square.png'
  class='post-inset-image'
/>

Fingers crossed this will be the last post of the [Hydra Chronicles][100], a.k.a.
"Everything You Didn't Want To Know About Group Statistics But Let Me Tell You
Anyway".  Well, it's more of an end note rather than a real post: a few tidbits
that ended up on the cutting floor in the earlier posts.

One of our early "discoveries" about group statistics is that if we can compute
the group sum, we can build on that to compute many other group statistics.
We'll go over here a few of the other strategies I tested out before I settled
on the [`cumsum` based approach][110] we used to "beat" `data.table`.

# rowsum

I did mention this one [in passing][120], but it bears re-examining:
`base::rowsum` is a remarkable creature in the base R ecosystem.  As far as I
know, it is the only R function that can compute group statistics on unequal
group sizes in statically compiled C code.  Despite this it is relatively
unknown, especially when compared with its popular cousin `base::rowSums`.

It likely doesn't help that the names of the two functions are barely
distinguishable, despite the difference in behavior.  `rowsum` collapses rows
together by group, leaving column count unchanged, whereas `rowSums` collapses
all columns in each row into a single scalar value:

```{r}
(mx <- matrix(rep(c(1, 2, 3), 2), nrow=3))
rowsum(mx, c('a', 'b', 'b'))
matrix(rowSums(mx))   # rowSums returns a vector
```

In the single column/vector case, `rowsum(x, grp)` is essentially equivalent to
`tapply(x, grp, sum)` (or `vapply(split(x, grp), sum, 0)`).

Let's look at some examples and timings with our beaten-to-death 10MM row, ~1MM
group [data set](#data), and our timing function [`sys.time`](#sys-time).  We'll
order the data first as [that is fastest][140] even when including the time to
order:

```{r eval=FALSE}
sys.time({
  o <- order(grp)
  go <- grp[o]
  xo <- x[o]
})
```
```
   user  system elapsed
  0.690   0.003   0.696
```

`tapply` first for reference:

```{r eval=FALSE}
sys.time(gsum.0 <- tapply(xo, go, sum))
```
```
   user  system elapsed
  2.273   0.105   2.383
```

And now `rowsum`:

```{r eval=FALSE}
sys.time(gsum.1 <- rowsum(xo, go))
```
```
   user  system elapsed
  0.507   0.038   0.546
```

```{r eval=FALSE}
all.equal(c(gsum.0), c(gsum.1), check.attributes=FALSE)
```
```
[1] TRUE
```

`rowsum` provides a noticeable speed-up over `tapply` for the same task, though
`data.table` remains faster:

```{r echo=FALSE}
step.levels <- c('order',  'rle*', 'sum')
funs <- c('tapply', 'tapply', 'rowsum', 'rowsum', 'data.table')
steps <- c('order', 'sum', 'order', 'sum', NA)
times <- data.frame(
  Function=factor(funs, levels=unique(funs)),
  # Version=c('data.table', 'group_slope', 'data.table', 'group_slope'),
  Step=factor(steps, levels=step.levels[-2]),
  time=c(.696, 2.383, .696, .546, 1.025)
)
brewer3 <- c('#66c2a5','#fc8d62','#8da0cb')
ggplot(times, aes(x=Function, y=time)) +
  geom_col(aes(fill=Step)) +
  # facet_grid(.~Function, scales='free_x', space='free_x') +
  ylab("Time in Sec (Less is Better)") +
  geom_label(
    data=data.table(times)[!is.na(Step)][
      order(Step, decreasing=TRUE),
      .(time=time, timec=cumsum(c(0,time[-length(time)]))),
      .(Function)
    ],
    aes(label=sprintf("%0.2f", time), y=timec + time/2)
  ) +
  geom_text(
    data=data.table(times)[, .(time=sum(time)), .(Function)],
    aes(label=sprintf("%0.2f", time)), vjust=-.2
  ) +
  scale_y_continuous(expand=expand_scale(mult=c(0, .1))) +
  scale_fill_manual(values=brewer3[-2], na.value='grey50', drop=FALSE)
```

The slow step for `data.table` is also the ordering, but we don't have a
good way to break that out.

# colSums

`base::rowSums`, the aforementioned better-known cousin of `rowsum`, also
computes group statistics with statically compiled code.  Well, it kind of does
if you consider matrix rows to be groups. `base::colSums` does the same except
for columns.  Suppose we have three equal sized ordered groups:

```{r}
(G <- rep(1:3, each=2))
```

And values that belong to them:

```{r}
set.seed(1)
(a <- runif(6))
```

We can compute the group sums using `colSums` by wrapping our vector into a
matrix with as many columns as there are groups.  Since R internally stores
matrices as vectors in column-major order, this is a natural operation (and also
why we use `colSums` instead of `rowSums`):

```{r}
(a.mx <- matrix(a, ncol=length(unique(G))))
colSums(a.mx)
```

This is equivalent to:

```{r}
c(rowsum(a, G))
```

We run into problems as soon as we have uneven group lengths, but there is a
workaround.  The idea is to use clever indexing to embed the values associated
with each group into columns of a matrix.  We illustrate this process with a
vector with 95 elements in ten groups.  For display purposes we wrap the vector
column-wise every ten elements, and designate the groups by a color.  The values
of the vector are not shown explicitly.

<!--
See static/post/2019-07-26-hydra-loose-ends_files/scripts/ for the code used to
generate the flipbook and animation.
-->

<script type='text/javascript'>
var img_dir = '/post/2019-07-26-hydra-loose-ends_files/user-imgs/flip-book/';
var fps_def = 1;
var img_n = 17;
var playing = true;
</script>
```{r child='../../static/chunks/flipbook.Rmd'}
```

The embedding step warrants additional explanation.  The trick is to generate a
vector that maps the positions in our irregular input vector into the regular
matrix.  There are several ways we can do this, but the one that we'll use today
takes advantage of the underlying vector nature of matrices.  In particular, we
will index into our matrices as if they were vectors, e.g.:

```{r}
(b <- 1:4)
(b.mx <- matrix(b, 2))
b[3]
b.mx[3]  # index vector underlying matrix directly
```

Let's look at our 95 data before and after embedding, showing the indices in
vector format for both our ordered vector and the target matrix:

```{r echo=FALSE}
library(data.table)
library(ggplot2)
library(gganimate)
# RNGversion("3.5.2");
set.seed(1)
gn <- 10
g2 <- sample(seq_len(gn), 95, replace=TRUE)
x <- runif(length(g2))
o <- order(g2)
go <- g2[o]
xo <- x[o]

 # Horrible horrible, but it works
labels <- c(
  'main',                  # original colored squares
  'main-back',             # background for original
  'group-lab',             # labels for first el in group
  'group-long',            # the path tracing longest group
  'group-long-end',        # the points at the end
  'pad-line',              # the lines showing the padding 
  'pad-end',               # end of padding lines
  'embed',                 # matrix to embed in
  'embed-idx',             # embedding indices
  #'embed-main',           # outline of embedding area
  NULL
)

 # labels are:
 # 0: original colored squares
 # 1: first set of re-allocation (first column)
 # 3: rest of reallocation
 # 4: background for colored squares
 # 5: original colored squares, but after the move
 # 6: the "path" that traces the group

gx <- (seq_along(g2) - 1) %/% 10
gy <- -((seq_along(g2) - 1) %% 10)
faint <- 0.2

 # Main elements

dat10 <- data.table(
  step=1L, id=seq_along(g2), g2, x=gx, y=gy, alpha=1, label='main',
  glabel=NA_character_, type='tile', tile.color=NA_character_,
  point.shape=NA_character_
)
dat10 <- rbind(copy(dat10)[, label:='main-back'], dat10)

 # Order foreground and add background cells

dat20 <- rbind(
  dat10[label == 'main-back'][order(g2)][, `:=`(x=gx, y=gy)],
  dat10[label == 'main'][order(g2)][, `:=`(x=gx, y=gy)]
)
dat20[, step:=2L]
g.rle <- rle(dat20[label == 'main'][['g2']])
g.max <- max(g.rle[['lengths']])
g.n <- length(g.rle[['lengths']])

 # group labels

dat30 <- rbind(
  dat20,
  dat20[label == 'main'][which(c(TRUE, diff(g2) != 0))][,
    `:=`(glabel=as.character(g2), label='group-lab', type='label')
  ]
)
dat30[, step:=3L]

 # move group labels

g.off <- 12L
x.off <- seq_len(g.n) + g.off - 1
g.long.x <- g.off

dat40 <- rbind(
  dat30[label != 'group-lab'],
  dat30[label == 'group-lab'][, `:=`(x=x.off, y=0)]
)
dat40[, step:=4L]


 # longest-group

dat50 <- rbind(fill=TRUE,
  dat40[label == 'main' & g2 == which.max(g.rle[['lengths']])][,
    `:=`(
      label='group-longest', type='point', id=seq_len(g.max),
      point.shape='a'
    )
  ],
  dat40
)
dat50[, step:=5L]

 # move longest group

dat60 <- copy(dat50)
dat60[label == 'group-longest',
  `:=`(
      x=g.off,
      y=-c(0, 10:1, 11:13)
  )
]
dat60[, step:=6L]

 # alloc matrix

dat70 <- rbind(fill=TRUE,
  data.table(
    id=seq_len(length(g.rle[['lengths']])),
    x=rep(x.off, g.max), y=-rev(rep(seq_len(g.max), each=g.n)) + 1L,
    label='embed', type='tile'
  ),
  dat60
)
dat70[, step:=7L]

 # compute padding

pads <- data.table(
  x=rep(g.off + (seq_len(g.n) - 1)),
  g.len=g.rle[['lengths']],
  id=rep(seq_len(g.n))
)
pads <- pads[,.(y=-head(seq(from=g.len, g.max, by=+1), -1L)), by=.(x)]

dat80 <- rbind(fill=TRUE,
  dat70[!label %in% c('group-longest', 'group-lab')],
  copy(pads)[, `:=`(label='pad', type='point', point.shape='b')]
  # dat50[label == 'main'][, `:=`(
  #     x=g.n + g2 + 0,
  #     y=-sequence(g.rle[['lengths']]) + 1, g2=g.n+1L,
  #     label='embed-main'
  #   )
  # ]
)
dat80[, step:=8L]

 # compute embedding indices

glen2 <- head(g.rle[['lengths']], -1L)
pad <- g.max - glen2
id0 <- rep(1L, length(g2))
id0[cumsum(glen2) + 1L] <- pad + 1L
id1 <- cumsum(id0)

dat90 <- rbind(fill=TRUE,
  copy(dat80),
  dat80[label == 'main'][, `:=`(
      x=g.off + g2 - 1,
      y=-sequence(g.rle[['lengths']]) + 1, g2=g.n+1L,
      label='embed-idx',
      type='label', glabel=as.character(id1)
) ] )
dat90[, step:=9L]

 # copy into embedding

dat100 <- rbind(
  dat90[!label %in% c('main', 'pad', 'embed-idx')],
  dat90[label == 'main'][, `:=`(
    x=g.off + g2 + -1, y=-sequence(g.rle[['lengths']]) + 1
) ] )
dat100[, step:=10L]

 # colSums

dat110 <- rbind(
  dat100[!label %in% c('main', 'embed', 'embed-idx')],
  dat100[label %in% c('main', 'embed')][, y:=0]
)
dat110[, step:=11L]

 # wrapup

dat120 <- dat110[label %in% c('main', 'main-back')][, `:=`(alpha=0)]
dat120[, step:=12L]

steps <- c(
  "An Algorithm to Compute Group Sums with colSums",
  "Start With Data in Random Groups",
  "Order by Group",
  "Count Groups",
  "One Column Per Group",
  "Length of Longest Group",
  "One Row Per Element In Longest Group",
  "Allocate Embedding Matrix",
  "Compute Padding in Embedding Matrix",
  "Compute Embedding Indices ...",
  "... And Use Them to Copy Each Group Into Its Column",
  "Compute colSums...",
  "... And Admire Them in 3D",
  NULL
)
dat05 <- copy(dat10)[, step:=0]
dat120 <- copy(dat110)[, step:=max(step) + 1]
dat <- rbind(
  dat05, dat10, dat20, dat30, dat40, dat50, dat60,
  dat70, dat80, dat90, dat100, dat110, dat120
)
dat[is.na(alpha), alpha:=1]
# dcast(dat[, .N, .(step, label)], label ~ step, fill=0)
stopifnot(all(dat[, type] %in% c('tile', 'label', 'path', 'point', 'text')))
dat[, Step:=factor(steps[match(step, unique(sort(step)))], levels=steps)]
dat[, g2f:=factor(g2, levels=as.character(sort(unique(g2))))]

 # Code to line up with the steps

code <- c(
'set.seed(1)

g <- sample(10, 95, r=TRUE)   # Group is shown as color
x <- runif(95)                # Value is 3D tile height',

'set.seed(1)

g <- sample(10, 95, r=TRUE)
x <- runif(95)',

'o <- order(g)
go <- g[o]
xo <- x[o]',

"g.rle <- rle(go)
g.lens <- g.rle[['lengths']]

# group count
g.n <- length(g.lens)",

"g.rle <- rle(go)
g.lens <- g.rle[['lengths']]

# group count
g.n <- length(g.lens)",

"g.rle <- rle(go)
g.lens <- g.rle[['lengths']]

# longest group
g.max <- max(g.lens)",

"g.rle <- rle(go)
g.lens <- g.rle[['lengths']]

# longest group
g.max <- max(g.lens)",

"res <- matrix(
  0, ncol=g.n, nrow=g.max
)",

"pad <- max(g.lens) - g.lens + 1L",

"g.lens.hd <- head(g.lens, -1L)
id0 <- rep(1L, length(xo))
id0[(cumsum(g.lens.hd) + 1L)] <- pad

id.embed <- cumsum(id0)",

"res[id.embed] <- xo",

"colSums(res)",

"# Group is shown as tile color
# Value is 3D tile height

colSums(res)",

# "",

NULL
)
dat.code <- data.table(text=code, Step=factor(steps))

 # dat <- subset(dat, step==steps[[5]])
 # dat.code <- subset(dat.code, step==steps[[5]])

library(ggplot2)
library(gganimate)

make_plot <- function(dat, dat.code, text.size=16) {
  p <- ggplot(mapping=aes(x, y, alpha=alpha, group=paste(label, id))) +
    geom_tile(
      data=subset(dat, type=='tile'), aes(fill=g2f),
      color='#AAAAAA'
    ) +
    geom_point(
      data=subset(dat, type=='point'), size=4,
      aes(shape=point.shape)
    ) +
    # geom_polygon(data=subset(dat, type=='path')) +
    geom_label(data=subset(dat, type=='label'), aes(label=glabel), size=5) +
    # geom_text(data=subset(dat, type=='text'), aes(label=glabel), size=5) +
    # we save the last group color for an off-scale color
    scale_fill_manual(
      guide=FALSE, na.value='#F3F3F3',
      values=setNames(
        c(viridisLite::viridis(g.n), 'grey50'),
        as.character(seq_len(g.n + 1L))
      )
    ) +
    scale_alpha(
      guide=FALSE, rescaler=function(x, to, from, ...) x, range=c(0,1)
    ) +
    scale_shape_manual(values=c(a=16, b=1), guide=FALSE) +
    theme(
      panel.grid.major=element_blank(), panel.grid.minor=element_blank(),
      axis.title.x=element_blank(), axis.text.x=element_blank(),
      axis.ticks.x=element_blank(),
      axis.title.y=element_blank(), axis.text.y=element_blank(),
      axis.ticks.y=element_blank(),
      plot.title=element_text(size=text.size)
    ) +
    NULL
    if(!is.null(dat.code)) {
      p <- p + geom_text(
        data=dat.code,
        aes(label=text, group=NULL, alpha=NULL, x=NULL, y=NULL),
        x=-0.5, y=-10,
        hjust=0, vjust=1, size=9, family='mono'
      )
    }
    p
}

```
```{r echo=FALSE, eval=FALSE}
# ## gganimate

steps.core <- tail(head(seq_len(nrow(dat.code)), -1L), -1L)
steps.new <- steps[steps.core]
dat.sub <- dat[!step %in% range(step)]
dat.sub[, Step:=droplevels(Step)]
dat.code.sub <- dat.code[steps.core]
dat.code.sub[, Step:=droplevels(Step)]

p <- make_plot(dat.sub, dat.code.sub, text.size=24)
p.anim <- p +
    coord_fixed(xlim=c(-0.5,21.5), ylim=c(0,-13)) +
    transition_states(Step, wrap=FALSE) +
    labs(title = "{next_state}") +
    # ease_aes('cubic-in-out') +
    enter_grow() +
    exit_shrink() +
    NULL

# anim_save(
#   '~/Downloads/colsums-anim-2.gif',
#   p.anim, width=1280, height=800, nframes=40, fps=5
# )
animate(
  p.anim,
  nframes = 400, fps=25, device = "png",
  renderer = file_renderer(
    "~/Downloads/colsums-anim/", prefix = "gganim-img", overwrite = TRUE
  ),
  width=1280, height=800
)

i.off <- -1
png.root <- '~/Downloads/colsums2/img-%03d.png'

for(i in seq_along(steps)) {
  file <- sprintf(png.root, i + i.off)
  png(file, width=1280, height=800)
  dat.sub <- subset(dat, Step==steps[[i]])
  dat.code.sub <- subset(dat.code, Step==steps[[i]])

  p <- make_plot(dat.sub, dat.code.sub, text.size=24) +
    ggtitle(steps[[i]]) +
    coord_fixed(xlim=c(-0.5,21.5), ylim=c(0,-13))
  print(p)
  dev.off()
  # remove color profile
  tmp <- png::readPNG(file)
  png::writePNG(tmp, file)
}

 ## Additional frames
 
 # dat.sub <- rbind(
 #   subset(dat, Step==steps[[5]] & label!=0),
 #   transform(subset(dat, Step==steps[[5]] & label==0), alpha=0.3),
 #   transform(
 #     subset(dat, Step==steps[[4]] & label==0), Step=steps[[5]], label=5
 #   )
 # )
 # dat.code.sub <- subset(dat.code, step==steps[[5]])

p <- make_plot(dat.sub, NULL)

idx1 <- subset(dat.sub, label==5, select=c(x, y, g2))
idx2 <- subset(dat.sub, label%in%c(0,1,3), select=c(x, y, g2))
idx2 <- idx2[with(idx2, order(x, -y, g2)),]
idx2.dup <- duplicated(idx2[1:2])
idx2 <- idx2[!idx2.dup,]

idx <- rbind(
  transform(idx1[with(idx1, order(x, -y)),], label=seq_along(x)),
  transform(idx2[with(idx2, order(x, -y)),], label=seq_along(x))
)
p + geom_text(data=idx, aes(x, y, label=label, colour=factor(g2))) +
  scale_colour_manual(
    guide=FALSE, values=rep(c('white', 'black'), c(2, 8)), na.value='black'
  )

p +
  geom_path(
    data=data.frame(
      x=c(4, 5, 5, 5, 5, 6, 6, 6), y=-c(9, 9, 9, 0, 0, 0, 0, 2), label=6,
      id=rep(1:4, each=2)
    ),
    aes(x, y, group=paste(label, id))
  ) +
  geom_point(
    data=data.frame(x=c(4, 6), y=-c(9, 2), label=6, id=5:6),
    aes(x, y)
  )

p +
  geom_path(
    data=data.frame(
      x=rep(11, 8), y=-c(0, 1, 1, 10, 10, 11, 11, 13), label=6,
      id=rep(1:4, each=2)
    ),
    aes(x, y, group=paste(label, id))
  ) +
  geom_point(
    data=data.frame(x=11, y=-c(0, 13), label=6, id=5:6),
    aes(x, y, group=paste(label, id))
  )
```

The indices corresponding to each group diverge after the first group due
to the unused elements of the embedding matrix.  What we're looking for is a
fast way to generate the indices in the colored cells in the matrix on the
right.  In other words, we want to generate the `id1` vector below (we show
the first three groups worth of it here):

```{r echo=FALSE, eval=FALSE}
g2.rle <- rle(sort(g2))

rle.len <- g2.rle[['lengths']][1:3]
gs <- rep(g2.rle[['values']][1:3], g2.rle[['lengths']][1:3])
max.g <- max(g2.rle[['lengths']])

g.pad <- max.g - rle.len + 1L
idx.raw <- rep(1L, length(gs))
idx.raw[(cumsum(rle.len) + 1L)] <- g.pad
idx <- cumsum(idx.raw[-length(idx.raw)])

xx <- rbind(gs, seq_along(idx), idx)
dimnames(xx) <- list(c('group', 'orig', 'embed'), rep('  ', ncol(xx)))
xx <- rbind(gs, seq_along(idx), c(NA, diff(seq_along(idx))), idx, c(NA, diff(idx)))
dimnames(xx) <- list(c('group', 'orig', 'orig ∆', 'embed', 'embed ∆'), rep('  ', ncol(xx)))
xx
```
```{r echo=FALSE}
writeLines('group      1  1  1  1  1  1  1  1  2  2  2  2  2  2  2  3  3  3  3  3  3  3
id0       \033[37;48;2;67;01;83m 1  2  3  4  5  6  7  8 \033[48;2;71;39;119m 9 10 11 12 13 14 15 \033[48;2;62;64;136m16 17 18 19 20 21 22 \033[m
id1       \033[37;48;2;67;01;83m 1  2  3  4  5  6  7  8 \033[48;2;71;39;119m15 16 17 18 19 20 21 \033[48;2;62;64;136m29 30 31 32 33 34 35 \033[m')
```

A helpful way to emphasize the relationship between these is to look at the
element by element difference in each index vector, e.g. using `diff`:<span
id=diff-id1></span>

```{r echo=FALSE}
writeLines('group      1  1  1  1  1  1  1  1  2  2  2  2  2  2  2  3  3  3  3  3  3  3
id0       \033[37;48;2;67;01;83m 1  2  3  4  5  6  7  8 \033[48;2;71;39;119m 9 10 11 12 13 14 15 \033[48;2;62;64;136m16 17 18 19 20 21 22 \033[m
diff(id0) NA  1  1  1  1  1  1  1 \033[32m 1 \033[m 1  1  1  1  1  1 \033[42m 1 \033[m 1  1  1  1  1  1
id1       \033[37;48;2;67;01;83m 1  2  3  4  5  6  7  8 \033[48;2;71;39;119m15 16 17 18 19 20 21 \033[48;2;62;64;136m29 30 31 32 33 34 35 \033[m
diff(id1) NA  1  1  1  1  1  1  1 \033[32m 7 \033[m 1  1  1  1  1  1 \033[42m 8 \033[m 1  1  1  1  1  1
')
```

The indices always increment by one, except for the embedded vector, where they
increment by `$1 + pad$`, where `$pad$` is how much empty space there is between
the end of the group and the end of the column it is embedded in.  Flipping this
around, this means all we need to be able to compute the embedding indices is
figure out the size of the column padding, which will be a function of the group
size and the largest group size.  Thankfully the `rle` computes the lengths of
repeated sequences, which in the case of our ordered group vector corresponds
exactly to group sizes:

```{r echo=FALSE}
g <- sort(g2)
```
```{r}
g.rle <- rle(sort(g))
g.rle
```

Padding is the difference between each group's size and that of the largest
group:

```{r}
g.max <- max(g.rle[['lengths']])  # largest group
pad <- g.max - g.rle[['lengths']]
```

To compute the embedding vector we start by a vector of the differences which
as a baseline are all 1:

```{r}
id0 <- rep(1L, length(g))
```

We then add the padding at each group transition.  Conveniently, the group
transitions are just one element past the length of the previous element, so we
can add the padding at the positions following the cumulative sum of the group lengths:

```{r}
id0[cumsum(g.rle[['lengths']]) + 1L] <- pad + 1L
head(id0, 22)   # first three groups
```

You'll notice this is essentially the same thing as `diff(id1)` [from
earlier](#diff-id1).  Thus, if we apply `cumsum` we reproduce `id1`:

```{r}
head(cumsum(id0), 22)
```
A distinguishing feature of these manipulations other than possibly inducing
death-by-boredom is that they are all in fast vectorized code.  This gives us
another reasonably fast group sum function.  We split it up into a function that
calculates the embedding index and one that does the embedding and sum, for
reasons that will become obvious later.  Assuming sorted inputs[^sorted-inputs]:

```{r eval=FALSE}
og_embed_dat <- function(go) {
  ## compute run length encoding
  g.rle <- rle(go)
  g.lens <- g.rle[['lengths']]
  max.g <- max(g.lens)

  ## compute padding
  g.lens <- g.lens[-length(g.lens)]
  g.pad <- max.g - g.lens + 1L

  ## compute embedding indices
  id0 <- rep(1L, length(go))
  id0[(cumsum(g.lens) + 1L)] <- g.pad
  id1 <- cumsum(id0)

  list(idx=id1, rle=g.rle)
}
og_sum_col <- function(xo, embed_dat, na.rm=FALSE) {
  ## group sizes
  rle.len <- embed_dat[['rle']][['lengths']]

  ## allocate embedding matrix
  res <- matrix(0, ncol=length(rle.len), nrow=max(rle.len))

  ## copy data using embedding indices
  res[embed_dat[['idx']]] <- xo
  setNames(colSums(res, na.rm=na.rm), embed_dat[['rle']][['values']])
}
sys.time(og_sum_col(xo, og_embed_dat(go)))
```
```
   user  system elapsed
  0.502   0.195   0.699
```

Most of the run time is actually the embedding index calculation:

```{r eval=FALSE}
sys.time(emb <- og_embed_dat(go))
```
```
   user  system elapsed
  0.369   0.141   0.510
```
```
sys.time(emb1 <- og_embed_dat0(go))
```

This is a little slower than `rowsum` for the simple group sum, but there are
benefits to this approach.  The main drawback is the potential for the embedding
matrix to become inefficiently large if a small number of groups are much larger
than the rest.  It may be possible to mitigate this by breaking up the data into
sub by groups[^colsums-breakup].

# Pedal To The Metal

Out of curiosity I wrote a [C version of `rowsum`,
`og_sum_C`](#og_sum_C) that takes advantage of group ordered
data to compute the group sums and counts, similar to our [re-implementation of
`unique` for sorted data][160].  We can detect group transitions any time the
group vector changes, and use that to store group values/counts and
reset the accumulators.  Once the data is sorted, this takes virtually no time:

```{r}
sys.time(og_sum_C(xo, go))
```
```
   user  system elapsed
  0.039   0.001   0.041
```
<!--
sys.time({
  o <- order(grp)
  og_sum_C(x[o], grp[o])
})
   user  system elapsed
  0.735   0.004   0.743
-->

Let's compare against all the different methods, including the [original
`cumsum` based group sum][110] (`cumsum-1`), and the [precision corrected two
pass version][170] (`cumsum-2`):

<!-- See static/..._files/scripts/benchmark.Rmd -->
```{r sum-benchmarks, echo=FALSE, warning=FALSE}
types <- rep(c('base',  'C', 'data.table'), c(5, 1, 1) * 3)
funs <- c(
  'tapply', 'cumsum-1', 'cumsum-2', 'rowsum', 'colSums',
  'og_sum_C',
  'simple'
)
steps <- c(rep(c('order',  'rle*', 'sum'), 6), rep(NA, 3))
times <- data.frame(
  Function=factor(rep(funs, each=3), levels=unique(funs)),
  Type=factor(types, levels=unique(types)),
  Step=factor(steps, levels=step.levels),
  time=c(
    .696,    NA, 2.624, # tapply
    .696, 0.514, 0.047, # cumsum-1
    .696, 0.514, 0.231, # cumsum-2
    .696,    NA, 0.583, # rowsum
    .696, 0.510, 0.189, # colSums
    .696,    NA, 0.044, # sum-only
   #.696  # full
      NA,    NA, 1.023  # simple
   #  NA,    NA,        # group-join-group
   #  NA,    NA,        # reformulate
  )
)
ggplot(times, aes(x=Function, y=time)) +
  geom_col(aes(fill=Step)) +
  # facet_wrap(~Type, scales='free_x') +
  facet_grid(.~Type, scales='free_x', space='free_x') +
  ylab("Time in Sec (Less is Better)") +
  # geom_label(
  #   data=data.table(times)[
  #     order(Step, decreasing=TRUE),
  #     .(time=time, timec=cumsum(c(0,time[-length(time)]))),
  #     .(Function, Type)
  #   ],
  #   aes(label=sprintf("%0.2f", time), y=timec + time/2)
  # ) +
  geom_text(
    data=data.table(times)[, .(time=sum(time, na.rm=TRUE)), .(Function, Type)],
    aes(label=sprintf("%0.2f", time)), vjust=-.2
  ) +
  scale_y_continuous(expand=expand_scale(mult=c(0, .1))) +
  scale_x_discrete(drop=TRUE) +
  scale_fill_manual(values=brewer3, na.value='grey50', drop=FALSE) +
  ggtitle("Group Sums, By Method")
```

We're actually able to beat `data.table` with our custom C code, although that
is only possible because `data.table` [contributed its fast radix sort to
R][180], and `data.table` requires more complex code to be able to run a broader
set of statistics.

The pattern to notice here is that for several of the methods the time spent
doing the actual summing is small.  For example, for `colSums`, most of the time
is ordering and computing the run length encoding / embedding indices (`rle*`).
This is important because those parts are a function of the grouping, so they
only need to be calculated once per group.  It doesn't help for single variable
group sums, but if we have more variables or more complex statistics it can make
a big difference.

Let's see how helpful re-using the group-based data is with the calculation of
the slope of a bivariate regression:

$$\frac{\sum(x_i - \bar{x})(y_i - \bar{y})}{\sum(x_i -
\bar{x})^{2}}$$

For illustrative purposes we'll show the implementation that uses the `colSums`
based group sum (`og_sum_col`).  Don't worry too much about the
details.  The key thing to note is that we use `og_sum_col` four times,
but we only compute the embedding data once:

```{r eval=FALSE}
g_slope_col <- function(x, y, group) {
  ## order
  o <- order(group)
  go <- group[o]
  xo <- x[o]
  yo <- y[o]

  ## compute group means for x/y
  emb <- og_embed_dat(go)
  lens <- emb[['rle']][['lengths']]
  ux <- og_sum_col(xo, emb)/lens
  uy <- og_sum_col(yo, emb)/lens

  ## recycle means to input vector length and compute
  ## (x - mean(x)) and (y - mean(y))
  gi <- rep(seq_along(ux), lens)
  x_ux <- xo - ux[gi]
  y_uy <- yo - uy[gi]

  ## Slope calculation
  gs.cs <- og_sum_col(x_ux * y_uy, emb) / og_sum_col(x_ux ^ 2, emb)
  setNames(gs.cs, emb[['rle']][['vaues']])
}
sys.time(g_slope_col(x, y, grp))
```
```
   user  system elapsed
  2.268   0.497   2.765
```

We can compare this to all the previous implementations of the group slope
calculation, as well as variations on the above based on `rowsum`,
[`og_sum_C`](#pedal-to-the-metal) (the C version of `rowsum` that operates
explicitly on group ordered ordered data), and finally a full C
version of the slope calculation to define the limit of how fast we can go:

<!-- See static/..._files/scripts/benchmark.Rmd -->
```{r slope-benchmarks, echo=FALSE, warning=FALSE}
types <- rep(c('base',  'C', 'data.table'), c(5, 2, 3))
funs <- c(
  'vapply', 'cumsum-1', 'cumsum-2', 'rowsum', 'colSums',
  'sum-only', 'full',
  'simple', 'optim', 'reformulated'
)
times <- data.frame(
  Function=factor(funs, levels=funs),
  Type=factor(types, levels=unique(types)),
  time=c(
   8.473, # tapply
   2.355, # cumsum-1
   3.020, # cumsum-2
   3.694, # rowsum
   2.765, # colSums
   1.641, # sum-only
   1.092, # full
   6.981, # simple
   3.117, # group-join-group
   1.516 # reformulate
  )
)
ggplot(times, aes(x=Function, y=time)) +
  geom_col() +
  facet_grid(.~Type, scales='free_x', space='free_x') +
  ylab("Time in Sec (Less is Better)") +
  # geom_label(
  #   data=data.table(times)[
  #     order(Step, decreasing=TRUE),
  #     .(time=time, timec=cumsum(c(0,time[-length(time)]))),
  #     .(Function, Type)
  #   ],
  #   aes(label=sprintf("%0.2f", time), y=timec + time/2)
  # ) +
  geom_text(
    data=data.table(times)[, .(time=sum(time, na.rm=TRUE)), .(Function, Type)],
    aes(label=sprintf("%0.2f", time)), vjust=-.2
  ) +
  scale_y_continuous(expand=expand_scale(mult=c(0, .1))) +
  ggtitle("Group Slopes, By Method")
```

Even though `rowsum` was the fastest group sum implementation, it is the
slowest of the base options outside of `split/vapply` because none of the
computation components other than the re-ordering can be re-used.  `colSums`
does pretty well and has the advantage of not suffering from the precision
issues of `cumsum-1`[^cumsum-1].  `cumsum-2`[^cumsum-2] might be the
best bet of the "base" solutions as it is only slightly slower than `colSums`
method, but should be scale better if there are some groups that are much larger
than most.

At most we

# Conclusions

With some thought and care it is possible to get within 2-3x
of "pure"[^driven-snow] C performance using only R code, for a task that at
first blush is not well suited for R.

<!-- this needs to become a shortcode -->
<!-- this is populated by JS in feedback.html partial -->
<div id='feedback-cont'></div>

# Appendix

## Acknowledgments

* This blog would not exist but for amazing contributions from many ...
* Rcpp/inline
* data.table (computations)
* ggplot
* viridisLite
* Color Brewer for the palette. http://colorbrewer2.org/#type=qualitative&scheme=Set2&n=3


## Data

```{r child='../../static/chunks/grp-dat.Rmd'}
```

## Functions

### sys.time

### og_sum_C

Similar to `rowsum`, except it requires ordered input, and it returns group
sizes as an attribute.  Group sizes allow us to either compute means or recycle
the result statistic back to the input length.

This is a limited, lightly tested, implementation that only works for double `x`
values and relies completely on the native code to handle NA/Infinite values.
It will ignore dimensions of matrices, and has undefined behavior if any group
has more elements than than `INT_MAX`.

Inputs must be ordered in increasing order by group, with if it exists the NA
group last.  The NA group will be treated as a single group (i.e. NA==NA is
TRUE).

```{r group_sum, eval=FALSE}
og_sum_C <- function(x, group) {
  stopifnot(
    typeof(x) == 'double', is.integer(group), length(x) == length(group)
  )
  tmp <- .og_sum_C(x, group)
  res <- setNames(tmp[[1]], tmp[[2]])
  attr(res, 'grp.size') <- tmp[[3]]
  res
}
.og_sum_C <- inline::cfunction(
  sig=c(x='numeric', g='integer'),
  body="
  R_xlen_t len, i, len_u = 1;
  SEXP res, res_x, res_g, res_n;
  int *gi = INTEGER(g);
  double *xi = REAL(x);
  len = XLENGTH(g);
  if(len != XLENGTH(x)) error(\"Unequal Length Vectors\");
  res = PROTECT(allocVector(VECSXP, 3));

  if(len > 1) {
    // count uniques
    for(i = 1; i < len; ++i) {
      if(gi[i - 1] != gi[i]) {
        ++len_u;
    } }
    // allocate and record uniques
    res_x = PROTECT(allocVector(REALSXP, len_u));
    res_g = PROTECT(allocVector(INTSXP, len_u));
    res_n = PROTECT(allocVector(INTSXP, len_u));

    double *res_xi = REAL(res_x);
    int *res_gi = INTEGER(res_g);
    int *res_ni = INTEGER(res_n);
    R_xlen_t j = 0;
    R_xlen_t prev_n = 0;

    res_xi[0] = 0;
    for(i = 1; i < len; ++i) {
      res_xi[j] += xi[i - 1];
      if(gi[i - 1] == gi[i]) {
        continue;
      } else if (gi[i - 1] < gi[i]){
        res_gi[j] = gi[i - 1];
        res_ni[j] = i - prev_n;  // this could overflow int; undefined?
        prev_n = i;
        ++j;
        res_xi[j] = 0;
      } else error(\"Decreasing group order found at index %d\", i + 1);
    }
    res_xi[j] += xi[i - 1];
    res_gi[j] = gi[i - 1];
    res_ni[j] = i - prev_n;

    SET_VECTOR_ELT(res, 0, res_x);
    SET_VECTOR_ELT(res, 1, res_g);
    SET_VECTOR_ELT(res, 2, res_n);
    UNPROTECT(3);
  } else {
    // Don't seem to need to duplicate x/g
    SET_VECTOR_ELT(res, 0, x);
    SET_VECTOR_ELT(res, 1, g);
    SET_VECTOR_ELT(res, 2, PROTECT(allocVector(REALSXP, 0)));
    UNPROTECT(1);
  }
  UNPROTECT(1);
  return res;
")
```

### g_slope_C

This is lightly tested.

```{r group_slope, eval=FALSE}
g_slope_C <- function(x, y, group) {
  stopifnot(
    typeof(x) == 'double', is.integer(group), length(x) == length(group),
    typeof(y) == 'double', length(x) == length(y)
  )
  o <- order(group)
  tmp <- .g_slope_C(x[o], y[o], group[o])
  res <- setNames(tmp[[1]], tmp[[2]])
  res
}
.g_slope_C <- inline::cfunction(
  sig=c(x='numeric', y='numeric',  g='integer'),
  body="
  R_xlen_t len, i, len_u = 1;
  SEXP res, res_x, res_g, res_y;
  int *gi = INTEGER(g);
  double *xi = REAL(x);
  double *yi = REAL(y);
  len = XLENGTH(g);
  if(len != XLENGTH(x)) error(\"Unequal Length Vectors\");
  res = PROTECT(allocVector(VECSXP, 2));

  if(len > 1) {
    // First pass compute unique groups
    for(i = 1; i < len; ++i) {
      if(gi[i - 1] != gi[i]) {
        ++len_u;
    } }
    // allocate and record uniques
    res_x = PROTECT(allocVector(REALSXP, len_u));
    res_y = PROTECT(allocVector(REALSXP, len_u));
    res_g = PROTECT(allocVector(INTSXP, len_u));

    double *res_xi = REAL(res_x);
    double *res_yi = REAL(res_y);
    int *res_gi = INTEGER(res_g);
    R_xlen_t j = 0;
    R_xlen_t prev_i = 0, n;

    // Second pass compute means

    double xac, yac;
    yac = xac = 0;
    for(i = 1; i < len; ++i) {
      xac += xi[i - 1];
      yac += yi[i - 1];
      if(gi[i - 1] == gi[i]) {
        continue;
      } else if (gi[i - 1] < gi[i]){
        n = i - prev_i;
        res_xi[j] = xac / n;
        res_yi[j] = yac / n;
        res_gi[j] = gi[i - 1];
        prev_i = i;
        yac = xac = 0;
        ++j;
      } else error(\"Decreasing group order found at index %d\", i + 1);
    }
    xac += xi[i - 1];
    yac += yi[i - 1];
    n = i - prev_i;
    res_xi[j] = xac / n;
    res_yi[j] = yac / n;
    res_gi[j] = gi[i - 1];

    // third pass compute slopes

    double xtmp, ytmp;
    yac = xac = xtmp = ytmp = 0;
    j = 0;

    for(i = 1; i < len; i++) {
      xtmp = xi[i - 1] -  res_xi[j];
      ytmp = yi[i - 1] -  res_yi[j];
      xac += xtmp * xtmp;
      yac += ytmp * xtmp;

      if(gi[i - 1] == gi[i]) {
        continue;
      } else {
        res_xi[j] = yac / xac;
        yac = xac = 0;
        ++j;
      }
    }
    xtmp = xi[i - 1] -  res_xi[j];
    ytmp = yi[i - 1] -  res_yi[j];
    xac += xtmp * xtmp;
    yac += ytmp * xtmp;
    res_xi[j] = yac / xac;

    SET_VECTOR_ELT(res, 0, res_x);
    SET_VECTOR_ELT(res, 1, res_g);
    UNPROTECT(3);
  } else {
    // Don't seem to need to duplicate x/g
    SET_VECTOR_ELT(res, 0, x);
    SET_VECTOR_ELT(res, 1, g);
    SET_VECTOR_ELT(res, 2, PROTECT(allocVector(REALSXP, 0)));
    UNPROTECT(1);
  }
  UNPROTECT(1);
  return res;
")
```

[^sorted-inputs]: We could have the function sort the inputs itself, but doing
  it this way allows us to compare to the other functions for which we pre-sort,
  and to re-use the ordering data when summarizing multiple variables.
[^colsums-breakup]: I implemented a test version to test feasibility and it had
  comparable performance
[^c-times]: Timing ordering and running `og_sum_C` separately versus together
  produces slightly different times, likely because by running the pieces
  separately it is possible to side-step a garbage collection event.  The
  timings in the plot are from running things together, and subtracting out the
  sorting / rle times.
[^driven-snow]: This is not strictly true as the ordering is done via a calls to
  `order` and `[`, although for those almost all the computations are done via
  statically compiled code.

[100]: /tags/hydra/
[110]: /2019/06/10/base-vs-data-table/#group-sums
[120]: /2019/06/10/base-vs-data-table/#rowsums
[130]: /2019/05/17/pixie-dust/#loose-ends
[140]: /2019/05/17/pixie-dust/
[150]: /2019/06/10/base-vs-data-table/#rowsums
[160]: /2019/06/10/base-vs-data-table/#interlude-better-living-through-sorted-data
[170]: /2019/06/18/hydra-precision/#a-new-hope
[180]: https://twitter.com/BrodieGaslam/status/1106231241488154626

