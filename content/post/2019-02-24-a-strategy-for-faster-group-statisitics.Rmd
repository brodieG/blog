---
title: A Strategy for Faster Group Statisitics
author: ~
date: '2019-02-24'
slug: a-strategy-for-faster-group-statisitics
categories: []
tags: []
draft: true
image: /front-img/default.png
imagemrgvt: 0%
imagemrghz: 0%
weight: 1
contenttype: article
description: Front page summary
---

```{r echo=FALSE}
options(digits=3)
knitr::opts_chunk$set(comment = "", fig.align='center', error=TRUE)
```

# Header 1

<!-- this needs to become a shortcode -->
<img
  id='front-img' src='/front-img/default.png'
  class='post-inset-image'
/>

A well known limitation of R is that there is substantial overhead to evaluate R
expressions.  This is not as bad as it sounds as the key workhorse R functions
quickly hand off to compiled C routines and avoid excessive overhead.  Generally
there are no problems so long as you avoid looping over long vectors with `for`,
the `*pply` family of functions, or otherwise.

Unfortunately there is one common use case where such looping is required:
computing statistics 

There
is one common use case

```
short <- runif(1)
long <- runif(1e7)
grp <- sample(1:1e6, 1e7, replace=TRUE)

microbenchmark::microbenchmark(sum(short), sum(long))
options(datatable.verbose = TRUE)

DT <- data.table(a=long, b=grp)
options(datatable.optimize=Inf)
system.time(DT[, sum(a), b])

short <- runif(1)
long <- runif(1e7)
grp <- sample(1:1e6, 1e7, replace=TRUE)

n <- 1e7
grp.size <- 10
set.seed(42)
grp <- sample(floor(n / grp.size), n, replace=TRUE)
x <- runif(n)
y <- runif(n)
id <- seq_len(n)

## Hmm, vapply/split faster than expected?

system.time({
  id.split <- split(id, grp)
  res3 <- vapply(id.split, function(id) slope(x[id], y[id]), 0)
})

library(data.table)
DT.raw <- data.table(grp, x, y)

# DT[, `:=`(ux=mean(x), uy=mean(y)), grp]
# DT[, ux:=sum(x), grp]

slope <- function(x, y) {
  ux <- mean.default(x)
  uy <- mean.default(y)
  sum((x - ux) * (y - uy)) / sum((x - ux) ^ 2)
}
DT <- copy(DT.raw)
system.time(res.old <- DT[, slope(x, y), keyby=grp])
system.time(res.old2 <- with(DT, tapply(slope(x, y), grp)))
system.time(DT[, mean(x), grp])
system.time(DT[, mean(x+y), grp])

slope2 <- function(x, y) {
  ux <- mean(x)
  uy <- mean(y)
  sum((x - ux) * (y - uy)) / sum((x - ux) ^ 2)
}
DT <- copy(DT.raw)
system.time(res.old <- DT[, slope2(x, y), keyby=grp])

DT <- copy(DT.raw)
system.time({
  setkey(DT, grp)
  DTsum <- DT[, .(ux=mean(x), uy=mean(y)), keyby=grp]
  DT[DTsum, `:=`(ux=ux, uy=uy)]
  DT[, `:=`(xux=x - ux, yuy=y - uy)]
  DT[, `:=`(xuxy=xux * yuy, xux2=xux^2)]
  DTsum2 <- DT[, .(xuxy=sum(xuxy), xux2=sum(xux2)), keyby=grp]
  res <- DTsum2[, .(grp, xuxy/xux2)]
})

DT <- copy(DT.raw)
system.time(setkey(DT, grp))
system.time(DTsum <- DT[, .(ux=mean(x), uy=mean(y)), keyby=grp])
system.time(DT[DTsum, `:=`(ux=ux, uy=uy)])
system.time(DT[, `:=`(xux=x - ux, yuy=y - uy)])
system.time(DTsum <- DT[, .(xux=sum(xux), yuy=sum(yuy)), keyby=grp])
system.time(res <- DTsum[, .(grp, xux * yuy / xux ^ 2)])

DT <- copy(DT.raw)
system.time({
  setkey(DT, grp)
  DT[, sum(x), keyby=grp]
})
DT <- copy(DT.raw)
system.time({
  DT[, sum(x), keyby=grp]
})

library(tibble)
library(dplyr)
DF <- tibble(grp, x, y)

DF %>% hybrid_call(mean(x))

system.time(
  res.dply <- DF %>% group_by(grp) %>% summarise(slope(x, y))
)
system.time(DF %>% group_by(grp) %>% summarise(mean(x)))
system.time(DF %>% group_by(grp) %>% summarise(mean(x + y)))
system.time(DF %>% mutate(z = x + y) %>% group_by(grp) %>% summarise(mean(z)))


DT <- data.table(a=1:10, grp=c(T, F))
options(datatable.verbose = TRUE)
options(datatable.optimize=Inf)
DT[, sum(a), grp]
DT[, suma:=sum(a), grp]


```
$$\frac{\sum(x_i - \bar{x})\sum(y_i - \bar{y})}{\sum(x_i -
\bar{x})^{2}}$$
```
```

# Conclusions

<!-- this needs to become a shortcode -->
<!-- this is populated by JS in feedback.html partial -->
<div id='feedback-cont'></div>

# Appendix

[1]: https://stackoverflow.com/a/29806540/2725969
