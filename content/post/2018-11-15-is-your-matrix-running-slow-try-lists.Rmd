---
title: Is Your Matrix Running Slow? Try Lists.
author: ~
date: '2018-11-15'
slug: is-your-matrix-running-slow-try-lists
draft: true
categories: [optimization]
tags: [rstats]
---

```{r echo=FALSE}
options(digits=3)
library(microbenchmark)
knitr::opts_chunk$set(
  comment = ""
)
```

## Matrices are Always Faster Than Data Frames, Right?

Generally speaking matrices are amongst the R data structures that are
fastest to operate on.  After all, they are contiguous chunks of memory with
almost no overhead.  Unfortunately, they do come with a major limitation: any
subset operation requires a copy of the data subset.  Consider:

```{r}
set.seed(1023)
v1 <- runif(1e5)
v2 <- runif(1e5)
v3 <- runif(1e5)
M <- cbind(v1, v2, v3)
D <- data.frame(v1, v2, v3)
microbenchmark(M[,1:2], D[,1:2], times=10)
```

The data frame subset is much faster because R treats data frame columns as
independent objects, so referencing an entire column does not require a copy if
the data is not modified.

## Awesome, I'll Just Use Data Frames! Right?

If you have been in R circles for any length of time you will inevitably have
heard something I will loosely paraphrase as:

> blah blah blah data frames are EVIL blah blah

However said that to you was not completely lying.  Let us see what happens if
we select rows and columns:

```{r}
idx <- sample(seq_len(nrow(M)), 5e4)
microbenchmark(M[idx,1:2], D[idx,1:2], times=10)
```

Ouch!  So we cannot just switch to data frames blindly.  But what is going on?
We can easily check how time is used by our expression with
[treeprof](https://github.com/brodieG/treeprof):

```{r eval=FALSE}
treeprof::treeprof(D[idx,1:2], target.time=1)
```
```{r echo=FALSE}
print(treeprof::treeprof(D[idx,1:2], target.time=1))
```

So `anyDuplicated` is taking a bunch of time, and while not obvious from the
profile data alone, this is because data frames do not like having duplicated
row names.  So let's introduce some duplicated row names to see what happens:

```{r eval=FALSE}
treeprof::treeprof(D[c(idx,idx[1]), 1:2], target.time=1)
```
```{r echo=FALSE}
print(treeprof::treeprof(D[c(idx,idx[1]), 1:2], target.time=1))
```

Holy horror show!  Data frame creates new character row names that now have to
be lugged around as a character vector.  This makes the data frame operation
several times slower than the corresponding matrix operation.  In exchange you
get:

```{r}
tail(rownames(D[c(idx,idx[1]), 1:2]))
```

Not. a. good. deal.

# Lists to the Rescue

With a little extra work you can do most of what you would normally do with a
matrix or data frame with a list.  It is not trivial or something I would want
to do on a regular basis, but for a package where performance it could be a
better alternative than compiled code or adding a dependency.

```{r}
L <- as.list(D)
identical(
  lapply(L[1:2], '[', idx),   ## apply `[` to each "column"
  as.list(D[idx,1:2])
)
microbenchmark(
  M[idx,1:2], D[idx,1:2], lapply(L[1:2], '[', idx), times=10
)
```

In the case in which we index rows the list/`lapply` method is comparable to the
matrix indexing.  And if we only index columns then the list is even faster
than the data frame:

```{r}
microbenchmark(M[,1:2], D[,1:2], L[1:2], times=10)
```

As hinted at by the `lapply(L[1:2], '[', idx)` construct earlier, unlocking the
speed benefits takes a little work.  Since R is a (mostly) functional
programming language with good list facilities, it can be fun and rewarding to
find the list equivalents of common matrix operations.  For example, to find the
distance between 2D points defined by `(v1,v2)` to those defined by `(v2,v3)` we
would use:

<a name='dist-calc'></a>
```{r dist-calc}
dist_m <- function(x, y) sqrt(rowSums((x - y)^2))
dist_l <- function(x, y) sqrt(Reduce("+", lapply(Map("-", x, y), "^", 2)))
```

These are equivalent:

```{r}
all.equal(dist_m(M[, 1:2], M[,2:3]), dist_l(L[1:2], L[2:3]))
```

For a detailed explanation of what these functions are doing [see the
appendix](#list-vs-matrix-example).

The theme is that we don't benefit from the natural vectorization of
base R functions across columns, so we have to explicitly execute that with
`Map`, `lapply`, `Reduce`, and other functional programming tools.  This is not
trivial, but with a little practice, functional manipulation of lists in R
becomes second hand.  And there is payoff:

```{r}
microbenchmark(dist_m(M[,1:2], M[,2:3]), dist_l(L[1:2], L[2:3]))
```

A 2x performance increase out of an expression like:
```{r eval=FALSE}
sqrt(rowSums((M[,1:2] - M[,2:3])^2))
```
is nothing to sneeze at.  There is no guarantee that the list approach will
always be faster, but if your data is tall (lots of observations) and skinny
(not too many variables), and you need to subset for columns a lot, the list
approach is a good option.  If the ratio of rows to columns is more in favor of
columns the cost overhead of explicitly looping over columns will likely give
matrix operations the edge.

# A Case Study

One of my side projects required me to implement [barycentric coordinate][1]
conversions to interpolate values from triangle vertices into the triangles
themselves.  So in the following diagram I wish to compute the barycentric
coordinates of each gray point relative to its enclosing triangle:

```{r echo=FALSE}
size <- 2
vert <- sin(60/180*pi)

x <- c(0, .5, 1)
y <- c(0, vert, 0)

x.rep <- 2
y.rep <- 4
rep <- x.rep * y.rep
x.off <- 2
y.off <- 1

xy.off <- as.matrix(
  expand.grid(x=(seq_len(x.rep) - 1) * x.off, y=(seq_len(y.rep) - 1) * y.off)
)[rep(seq_len(rep), each=3),]
tri.up <- cbind(
  cbind(rep(x, rep), rep(y, rep)) + xy.off, id=rep(seq_len(rep), each=3)
)
tri.down <- tri.up
tri.down[,'y'] <- -tri.down[,'y']
tri.down[,'y'] <- tri.down[,'y'] - min(tri.down[,'y'])
tri.down[,'x'] <- tri.down[,'x'] + 1
tri.down[,'id'] <- tri.down[,'id'] + max(tri.down[,'id'])

meshdf <- as.data.frame(rbind(tri.up, tri.down))
meshdf <- transform(meshdf,
  x.mid=ave(x, id, FUN=function(z) mean(range(z))),
  y.mid=ave(y, id, FUN=function(z) mean(range(z)))
)
meshdf <- with(meshdf, meshdf[order(y.mid + x.mid / (rep * 2)),])
meshdf$id <- rep(seq_len(rep * 2), each=3)
meshdf$idv <- seq_len(nrow(meshdf))

colstep <- 256 / (size * 2)^2
meshdf <- transform(
  meshdf,
  r=((id * colstep) - 1) * c(1, 0, 0) / 255,
  g=((id * colstep) - 1) * c(0, 1, 0) / 255,
  b=((id * colstep) - 1) * c(0, 0, 1) / 255
)
meshdf <- transform(meshdf, color=rgb(r, g, b))

n <- 30
mrg <- .025
rng.x <- diff(range(x))
rng.y <- diff(range(y))
points <- expand.grid(
  x=seq(min(x) + mrg * rng.x, max(x) - mrg * rng.x, length.out=n),
  y=seq(min(y) + mrg * rng.y, max(y) - mrg * rng.y, length.out=n)
)
points.all <- do.call(
  rbind,
  lapply(
    sort(unique(meshdf$id)),
    function(z) {
      transform(points,
        id=z, x=x + (z-1) %% y.rep * x.off / 2, y=y + (z-1) %/% y.rep * y.off
) } ) )

ggplot(meshdf) +
  geom_point(aes(x, y, color=I(color))) +
  geom_polygon(aes(x, y, group=id), alpha=0, color='black') +
  geom_point(data=points.all, aes(x, y), size=0.1) +
  geom_label(aes(x.mid, y.mid, label=id))

mesh1 <- meshdf[seq(1, len=rep*2, by=3), c('x','y','r','g','b')]
mesh2 <- meshdf[seq(2, len=rep*2, by=3), c('x','y','r','g','b')]
mesh3 <- meshdf[seq(3, len=rep*2, by=3), c('x','y','r','g','b')]

names(mesh1) <- paste0(names(mesh1), "1")
names(mesh2) <- paste0(names(mesh2), "2")
names(mesh3) <- paste0(names(mesh3), "3")

mesh.all <- cbind(mesh1, mesh2, mesh3)

mesharr[,,1] <- 
mesharr[,,2] <- meshdf[seq(1, len=rep*2, by=2), c('x','y','r','g','b')]
mesharr[,,3] <- meshdf[seq(1, len=rep*2, by=2), c('x','y','r','g','b')]

aperm(
  array(
    as.matrix(meshdf[]),
    c(3, 5, nrow(meshdf)/3)
  ),
  c(3,1,2)
)

# generate points inside


diff(range(x)) * .9 + min(x) * 1/.9


library(ggplot2)
ggplot(meshdf) + geom_polygon(aes(x,y,group=id)) +

bary_m <- function(M) {
  det <- (M[,'y2']-M[,'y3'])*(M[,'x1']-M[,'x3']) +
         (M[,'x3']-M[,'x2'])*(M[,'y1']-M[,'y3'])

  l1 <- (
          (M[,'y2']-M[,'y3']) * (M[,'x']-M[,'x3']) +
          (M[,'x3']-M[,'x2']) * (M[,'y']-M[,'y3'])
        ) / det
  l2 <- (
          (M[,'y3']-M[,'y1']) * (M[,'x']-M[,'x3']) +
          (M[,'x1']-M[,'x3']) * (M[,'y']-M[,'y3'])
        ) / det
  l3 <- 1 - l1 - l2
  cbind(l1, l2, l3)
}
bary_l <- function(L) {
  det <- (L['y2']-L['y3'])*(L['x1']-L['x3']) +
         (L['x3']-L['x2'])*(L['y1']-L['y3'])

  l1 <- (
          (L['y2']-L['y3']) * (L['x']-L['x3']) +
          (L['x3']-L['x2']) * (L['y']-L['y3'])
        ) / det
  l2 <- (
          (L['y3']-L['y1']) * (L['x']-L['x3']) +
          (L['x1']-L['x3']) * (L['y']-L['y3'])
        ) / det
  l3 <- 1 - l1 - l2
  list(l1, l2, l3)
}



```

# Appendix

## List Vs Matrix Example

Recall `dist_l` and `dist_m` from the [distance calculation
example](#dist-calc):

```{r dist-calc}
```

Here we break down each function into component steps by saving the intermediary
results into variables.  The first step is to compute the pairwise differences
between our columns:

```{r}
xL <- L[1:2];  yL <- L[2:3]
xM <- M[,1:2]; yM <- M[,2:3]

diffL <-      Map("-", xL, yL)   # with lists
diffM <-      xM - yM            # with matrices
str(diffL)
str(diffM)
```

Obviously the matrix calculation is simpler, but the list version is effectively
equivalent (minus the structure of the result), and extends naturally to any
equal number of columns in `x` and `y`.  We could also just as easily substitute
the "-" operator for any other binary operator or function as we could with the
matrices.

We then use a standard `lapply` to square each of the differences:

```{r}
diffsqL <-    lapply(diffL, "^", 2)
diffsqM <-    diffM ^ 2
```

Finally, we can use `Reduce` to sum across columns as a replacement for
`rowSums`:

```{r}
sqsumL <-     Reduce("+", diffsqL)
sqsumM <-     rowSums(diffsqM)

all.equal(sqrt(sqsumL), sqrt(sqsumM))
```



[1]: https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Barycentric_coordinates_on_triangles
