---
title: A Strategy for Faster Group Statisitics
author: ~
date: '2019-02-24'
slug: a-strategy-for-faster-group-statisitics
categories: []
tags: []
image: /front-img/default.png
imagemrgvt: 0%
imagemrghz: 0%
weight: 1
contenttype: article
description: Front page summary
---



<div id="header-1" class="section level1">
<h1>Header 1</h1>
<!-- this needs to become a shortcode -->
<p><img
  id='front-img' src='/front-img/default.png'
  class='post-inset-image'
/></p>
<p>A well known limitation of R is that there is substantial overhead to evaluate R
expressions. This is not as bad as it sounds as the key workhorse R functions
quickly hand off to compiled C routines and avoid excessive overhead. Generally
there are no problems so long as you avoid looping over long vectors with <code>for</code>,
the <code>*pply</code> family of functions, or otherwise.</p>
<p>Unfortunately there is one common use case where such looping is required:
computing statistics</p>
<p>There
is one common use case</p>
<pre><code>short &lt;- runif(1)
long &lt;- runif(1e7)
grp &lt;- sample(1:1e6, 1e7, replace=TRUE)

microbenchmark::microbenchmark(sum(short), sum(long))
options(datatable.verbose = TRUE)

DT &lt;- data.table(a=long, b=grp)
options(datatable.optimize=Inf)
system.time(DT[, sum(a), b])

short &lt;- runif(1)
long &lt;- runif(1e7)
grp &lt;- sample(1:1e6, 1e7, replace=TRUE)

n &lt;- 1e7
grp.size &lt;- 10
set.seed(42)
grp &lt;- sample(floor(n / grp.size), n, replace=TRUE)
x &lt;- runif(n)
y &lt;- runif(n)
id &lt;- seq_len(n)

system.time({
  id.split &lt;- split(id, grp)
  res3 &lt;- vapply(id.split, function(id) slope(x[id], y[id]), 0)
})

DT.raw &lt;- data.table(grp, x, y)

# DT[, `:=`(ux=mean(x), uy=mean(y)), grp]
# DT[, ux:=sum(x), grp]
# 
# 

slope &lt;- function(x, y) {
  ux &lt;- mean.default(x)
  uy &lt;- mean.default(y)
  sum((x - ux) * (y - uy)) / sum((x - ux) ^ 2)
}
DT &lt;- copy(DT.raw)
system.time(res.old &lt;- DT[, slope(x, y), keyby=grp])
system.time(res.old2 &lt;- with(DT, tapply(slope(x, y), grp)))

slope2 &lt;- function(x, y) {
  ux &lt;- mean(x)
  uy &lt;- mean(y)
  sum((x - ux) * (y - uy)) / sum((x - ux) ^ 2)
}
DT &lt;- copy(DT.raw)
system.time(res.old &lt;- DT[, slope2(x, y), keyby=grp])

DT &lt;- copy(DT.raw)
system.time({
  setkey(DT, grp)
  DTsum &lt;- DT[, .(ux=mean(x), uy=mean(y)), keyby=grp]
  DT[DTsum, `:=`(ux=ux, uy=uy)]
  DT[, `:=`(xux=x - ux, yuy=y - uy)]
  DT[, `:=`(xuxy=xux * yuy, xux2=xux^2)]
  DTsum2 &lt;- DT[, .(xuxy=sum(xuxy), xux2=sum(xux2)), keyby=grp]
  res &lt;- DTsum2[, .(grp, xuxy/xux2)]
})

DT &lt;- copy(DT.raw)
system.time(setkey(DT, grp))
system.time(DTsum &lt;- DT[, .(ux=mean(x), uy=mean(y)), keyby=grp])
system.time(DT[DTsum, `:=`(ux=ux, uy=uy)])
system.time(DT[, `:=`(xux=x - ux, yuy=y - uy)])
system.time(DTsum &lt;- DT[, .(xux=sum(xux), yuy=sum(yuy)), keyby=grp])
system.time(res &lt;- DTsum[, .(grp, xux * yuy / xux ^ 2)])

DT &lt;- copy(DT.raw)
system.time({
  setkey(DT, grp)
  DT[, sum(x), keyby=grp]
})
DT &lt;- copy(DT.raw)
system.time({
  DT[, sum(x), keyby=grp]
})


DT &lt;- data.table(a=1:10, grp=c(T, F))
options(datatable.verbose = TRUE)
options(datatable.optimize=Inf)
DT[, sum(a), grp]
DT[, suma:=sum(a), grp]

</code></pre>
<p><span class="math display">\[\frac{\sum(x_i - \bar{x})\sum(y_i - \bar{y})}{\sum(x_i -
\bar{x})^{2}}\]</span></p>
<pre><code></code></pre>
</div>
<div id="conclusions" class="section level1">
<h1>Conclusions</h1>
<!-- this needs to become a shortcode -->
<!-- this is populated by JS in feedback.html partial -->
<div id="feedback-cont">

</div>
</div>
<div id="appendix" class="section level1">
<h1>Appendix</h1>
</div>
